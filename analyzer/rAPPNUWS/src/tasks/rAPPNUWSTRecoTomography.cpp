////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// rAPPNUWSTRecoTomography                                                    //
//                                                                            //
// Begin_Html <!--
/*-->

<!--*/
// --> End_Html
//                                                                            //
//                                                                            //
// Please note: The following information is only correct after executing     //
// the ROMEBuilder.                                                           //
//                                                                            //
// This task accesses the following folders :                                 //
//     BTTTTracksScatter                                                      //
//     PreTomography                                                          //
//                                                                            //
//                                                                            //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

/* Generated header file containing necessary includes                        */
#include "generated/rAPPNUWSTRecoTomographyGeneratedIncludes.h"

////////////////////////////////////////////////////////////////////////////////
/*  This header was generated by ROMEBuilder. Manual changes above the        *
 * following line will be lost next time ROMEBuilder is executed.             */
/////////////////////////////////////----///////////////////////////////////////

#include "generated/rAPPNUWSAnalyzer.h"
#include "tasks/rAPPNUWSTRecoTomography.h"
#include "ROMEiostream.h"

// uncomment if you want to include headers of all folders
//#include "rAPPNUWSAllFolders.h"

#include "CSMTtracker.hh"
#include "CSMBtracker.hh"
#include "CSMTTROGeometryHandle.hh"
#include "CSMBTROGeometryHandle.hh"
#include "utilFunctions.hh"

#include "CLHEP/Vector/ThreeVector.h"

#include <cmath>
#include <unordered_map>
#include <vector>


ClassImp(rAPPNUWSTRecoTomography)

//______________________________________________________________________________
void rAPPNUWSTRecoTomography::Init()
{
    fGeometry = GeometrySrvHndl::Instance();
    if(!fGeometry->GetCSMTTROChanHandle() || !fGeometry->GetCSMBTROChanHandle())
        fGeometry->makeDetectors();

    sideWidth[0] = 2.0*fGeometry->GetCSMTtracker()->halfWidth();
    sideWidth[1] = fGeometry->GetCSMTtracker()->distIn();
    sideWidth[2] = 2.0*fGeometry->GetCSMTtracker()->zHalfLength();

    minVoxPos[0] = round( -fGeometry->GetCSMTtracker()->halfWidth() );
    minVoxPos[1] = 0.0;
    minVoxPos[2] = round( -fGeometry->GetCSMTtracker()->zHalfLength() );

    stepVox[0] = GetSP()->GetVoxelSizeX();
    stepVox[1] = GetSP()->GetVoxelSizeY();
    stepVox[2] = GetSP()->GetVoxelSizeZ();

    for (int isd=0; isd<3; ++isd) {
        nVox[isd] = floor( sideWidth[isd]/stepVox[isd] );
        sideWidth[isd] = nVox[isd]*stepVox[isd];
        maxVoxPos[isd] = minVoxPos[isd] + sideWidth[isd];
    }

    if (GetSP()->GetDebugLevel()) {
        std::cout<<"nVoxel "<<nVox[0]<<" "<<nVox[1]<<" "<<nVox[2]<<std::endl;
        std::cout<<"minVoxelPos "<<minVoxPos[0]<<" "<<minVoxPos[1]<<" "<<minVoxPos[2]<<std::endl;
        std::cout<<"maxVoxelPos "<<maxVoxPos[0]<<" "<<maxVoxPos[1]<<" "<<maxVoxPos[2]<<std::endl;
    }

}

//______________________________________________________________________________
void rAPPNUWSTRecoTomography::BeginOfRun()
{
}

//______________________________________________________________________________
void rAPPNUWSTRecoTomography::Event()
{

    if (gAnalyzer->GetCurrentEventNumber()%100==0) { printf("\n rAPPNUWSTRecoTomography::Event ***** Load event %lld ************************ \n",gAnalyzer->GetCurrentEventNumber()); }

//    fBrDataScatt = gAnalyzer->GetBTTTTracksScatters();

    doPreTomography();

}

//______________________________________________________________________________
void rAPPNUWSTRecoTomography::EndOfRun()
{
}

//______________________________________________________________________________
void rAPPNUWSTRecoTomography::Terminate()
{
}

void rAPPNUWSTRecoTomography::doPreTomography() {

    int fDebug=GetSP()->GetDebugLevel();
//    int nGoodVertex=0;
    std::unordered_map< unsigned long, std::vector<double> > voxHitMap;
    //    std::vector<int *>

    for (int isp=0; isp<gAnalyzer->GetBTTTTracksScatterSize(); ++isp) {
        rAPPNUWSBTTTTracksScatter* tmpScPnt = gAnalyzer->GetBTTTTracksScatterAt(isp);
        TVector3 *scpos = tmpScPnt->Getpos();
        Double_t scposArr[3];
        scpos->GetXYZ(scposArr);
        bool checkIn=true;
        for (int isd=0; isd<3; ++isd) {
            checkIn = checkIn && (scposArr[isd]>=minVoxPos[isd]) && (scposArr[isd]<=maxVoxPos[isd]);
        }
        if (fDebug){
            std::cout<<"Point ";scpos->Print();std::cout<<std::endl;
            std::cout<<"In "<<checkIn<<std::endl;
        }

        int Id[3] = {-1,-1,-1};
        if (checkIn) {
//            ++nGoodVertex;
            for (int isd=0; isd<3; ++isd) {
                Id[isd] = floor( (scposArr[isd] - minVoxPos[isd])/stepVox[isd] );
            }
            unsigned long uid=IDdoUID(Id);
            voxHitMap[uid].push_back(tmpScPnt->Getangle());
            if (fDebug>1) {
                std::cout<<" map Ids "<<Id[0]<<" "<<Id[1]<<" "<<Id[2]<<std::endl;
                int tmpId[3] = {-1,-1,-1};
                UIDtoID(uid, tmpId);
                std::cout<<"UID "<<uid<<" back to ID "<<tmpId[0]<<" "<<tmpId[1]<<" "<<tmpId[2]<<std::endl;
            }
        }

    }

    gAnalyzer->SetPreTomographySize(voxHitMap.size());

    int iHit=0;
    for ( auto& voxHit : voxHitMap)  {
        rAPPNUWSPreTomography *iVxHit = gAnalyzer->GetPreTomographyAt(iHit);
//        int tmpId[3] = {-1,-1,-1};
//        UIDtoID(voxHit.first, tmpId);
//        iVxHit->SethitIdCopy(3, tmpId);
        iVxHit->SethitId(voxHit.first);
        iVxHit->SethitPerVoxel(voxHit.second.size());
        double mtheta=0;
        double mtheta2=0;
        for ( auto& itheta : voxHit.second ) {
            mtheta+=itheta;
            mtheta2+=itheta*itheta;
        }
        mtheta/=(double) voxHit.second.size();
        mtheta2/=(double) voxHit.second.size();
        iVxHit->Setmeantheta(mtheta);
        iVxHit->Setsigmatheta( sqrt( mtheta2-mtheta*mtheta ) );
        iVxHit->Setalltheta(voxHit.second);
        ++iHit;
    }

}
