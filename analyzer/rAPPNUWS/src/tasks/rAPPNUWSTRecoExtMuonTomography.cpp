////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// rAPPNUWSTRecoExtMuonTomography                                             //
//                                                                            //
// Begin_Html <!--
/*-->

<!--*/
// --> End_Html
//                                                                            //
//                                                                            //
// Please note: The following information is only correct after executing     //
// the ROMEBuilder.                                                           //
//                                                                            //
// This task accesses the following folders :                                 //
//     CSMBTHit                                                               //
//     CSMTTHit                                                               //
//     RecoTracksBT                                                           //
//     RecoTracksTT                                                           //
//     BTTTTracksScatter                                                      //
//     PreTomographyInfo                                                      //
//     PreTomography                                                          //
//     PreExtMuonTomography                                                   //
//                                                                            //
//                                                                            //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

/* Generated header file containing necessary includes                        */
#include "generated/rAPPNUWSTRecoExtMuonTomographyGeneratedIncludes.h"

////////////////////////////////////////////////////////////////////////////////
/*  This header was generated by ROMEBuilder. Manual changes above the        *
 * following line will be lost next time ROMEBuilder is executed.             */
/////////////////////////////////////----///////////////////////////////////////

#include "generated/rAPPNUWSAnalyzer.h"
#include "tasks/rAPPNUWSTRecoExtMuonTomography.h"
#include "ROMEiostream.h"

// uncomment if you want to include headers of all folders
//#include "rAPPNUWSAllFolders.h"

#include "CSMTtracker.hh"
#include "CSMBtracker.hh"
#include "CSMTTROGeometryHandle.hh"
#include "CSMBTROGeometryHandle.hh"
#include "utilFunctions.hh"
#include "TomoUtils.h"

//In Ext MuonTomography the axis are x: longituninal (left->right), y: transversal (front->back), z: Vertical (down->Up)
//This means that the following conversion are needed:
// From framework to Ext M.T.: x->y, y->z, z->x (+ center offset) (rot: 90° around x, 90° around z)
// From Ext M.T. to framework: x->z, y->x, z->y (- center offset)

#include "MutoPoCA.h"

#include "CLHEP/Vector/ThreeVector.h"

#include <cmath>
#include <unordered_map>
#include <vector>
#include <utility>
#include <chrono>

ClassImp(rAPPNUWSTRecoExtMuonTomography)

//______________________________________________________________________________
void rAPPNUWSTRecoExtMuonTomography::Init()
{
    fGeometry = GeometrySrvHndl::Instance();
    if(!fGeometry->GetCSMTTROChanHandle() || !fGeometry->GetCSMBTROChanHandle())
        fGeometry->makeDetectors();

    sideWidth[0] = 2.0*fGeometry->GetCSMTtracker()->halfWidth();
    sideWidth[1] = fGeometry->GetCSMTtracker()->distIn();
    sideWidth[2] = 2.0*fGeometry->GetCSMTtracker()->zHalfLength();

    minVoxPos[0] = round( -fGeometry->GetCSMTtracker()->halfWidth() );
    minVoxPos[1] = 0.0;
    minVoxPos[2] = round( -fGeometry->GetCSMTtracker()->zHalfLength() );

    stepVox[0] = GetSP()->GetVoxelSizeX();
    stepVox[1] = GetSP()->GetVoxelSizeY();
    stepVox[2] = GetSP()->GetVoxelSizeZ();

    for (int isd=0; isd<3; ++isd) {
        nVox[isd] = floor( sideWidth[isd]/stepVox[isd] );
        sideWidth[isd] = nVox[isd]*stepVox[isd];
        maxVoxPos[isd] = minVoxPos[isd] + sideWidth[isd];
    }

    header.method = GetSP()->GetTomoMethod();
    if (header.method.compare("poca")==0) {
        rec = new extmutom::MutoPoCA();
        ((extmutom::MutoPoCA*) rec) -> SetGrid(nVox[2], nVox[0], nVox[1], minVoxPos[2], minVoxPos[0], minVoxPos[1], stepVox[2], stepVox[0], stepVox[1]);
//        ((extmutom::MutoPoCA*) rec) -> SetGrid(VoxelGrid grid);
//        ((extmutom::MutoPoCA*) rec) -> setAngMag(MTfloat fAngMag);
//        ((extmutom::MutoPoCA*) rec) -> setEps(MTfloat fEps);
//        ((extmutom::MutoPoCA*) rec) -> setHasEnergy(bool fHasEnergy);
//        ((extmutom::MutoPoCA*) rec) -> setLengthWeighted(bool fLengthWeighted);
//        ((extmutom::MutoPoCA*) rec) -> setLogPrint(bool fLogPrint);
//        ((extmutom::MutoPoCA*) rec) -> setNNotParallel(int fNNotParallel);
//        ((extmutom::MutoPoCA*) rec) -> setNScatInGrid(int fNScatInGrid);
//        ((extmutom::MutoPoCA*) rec) -> setNTotal(int fNTotal);
//        ((extmutom::MutoPoCA*) rec) -> setStraightLine(bool fStraightLine);

        header.grid = ((extmutom::MutoPoCA*) rec) -> getCurrentGrid();
        header.nIter = 1;
    } /*else if (config.exist("mlsd")) {
        method = "mlsd";
        rec = new MutoMLSD(config.get("mlsd"));
        header.grid = ((MutoMLSD*) rec) -> getCurrentGrid();
        header.nIter = config.get("mlsd")["num_iteration"];
    } else if (config.exist("map")) {
        method = "map";
        rec = new MutoMAP(config.get("map"));
        header.grid = ((MutoMAP*) rec) -> getCurrentGrid();
        header.nIter = config.get("map")["num_iteration"];
    } else if (config.exist("slr")) {
        method = "slr";
        rec = new MutoSLR(config.get("slr"));
        header.grid = ((MutoSLR*) rec) -> getCurrentGrid();
        header.nIter = 1;
    } else if (config.exist("slr_iter")) {
        method = "slr_iter";
        rec = new MutoSLRIter(config.get("slr_iter"));
        header.grid = ((MutoSLRIter*) rec) -> getCurrentGrid();
        header.nIter = 1;
    } else if (config.exist("pocut")) {
        method = "pocut";
        rec = new MutoPoCut(config.get("pocut"));
        header.grid = ((MutoPoCut*) rec) -> getCurrentGrid();
        header.nIter = 1;
    }*/

    data.clear();

    //rotation
    convRot.RotateX(TMath::PiOver2());
    convRot.RotateZ(TMath::PiOver2());
    convRotInv = convRot.Inverse();

    if (GetSP()->GetDebugLevel()) {
        std::cout<<"nVoxel "<<nVox[0]<<" "<<nVox[1]<<" "<<nVox[2]<<std::endl;
        std::cout<<"minVoxelPos "<<minVoxPos[0]<<" "<<minVoxPos[1]<<" "<<minVoxPos[2]<<std::endl;
        std::cout<<"maxVoxelPos "<<maxVoxPos[0]<<" "<<maxVoxPos[1]<<" "<<maxVoxPos[2]<<std::endl;
    }

}

//______________________________________________________________________________
void rAPPNUWSTRecoExtMuonTomography::BeginOfRun()
{
}

//______________________________________________________________________________
void rAPPNUWSTRecoExtMuonTomography::Event()
{

    if (gAnalyzer->GetCurrentEventNumber()%100==0) { printf("\n rAPPNUWSTRecoTomography::Event ***** Load event %lld ************************ \n",gAnalyzer->GetCurrentEventNumber()); }

//    fBrDataScatt = gAnalyzer->GetBTTTTracksScatters();

//    gAnalyzer->SetPreTomographyInfoSize(1);
//
//    rAPPNUWSPreTomographyInfo *tomInfo = gAnalyzer->GetPreTomographyInfoAt(0);
//    tomInfo->SetminVolexPosCopy(3, minVoxPos);
//    tomInfo->SetmaxVolexPosCopy(3, maxVoxPos);
//    tomInfo->SetnVolexCopy(3, nVox);
//
//    doPreTomography();

    DataFill();

}

//______________________________________________________________________________
void rAPPNUWSTRecoExtMuonTomography::EndOfRun()
{
}

//______________________________________________________________________________
void rAPPNUWSTRecoExtMuonTomography::Terminate()
{

    header.fPrecision = 4;
    header.nRay = data.size();

    // start timing
    auto ts = std::chrono::steady_clock::now();

    //Do Reconstruction
    extmutom::Image img = rec->reconstruct(data);

    // stopwatch
    auto time_span = std::chrono::duration_cast<std::chrono::duration<double>>(std::chrono::steady_clock::now() - ts);
    std::cout << "Reconstruction with <" << header.method << ">, n. of traks "<<header.nRay<<" took: " << time_span.count() << " seconds. " << std::endl;

    savePreTomography(img);

//    std::string output = config.get("output_file");

}

void rAPPNUWSTRecoExtMuonTomography::DataFill() {

    int fDebug=GetSP()->GetDebugLevel();
//    std::unordered_map< unsigned long, std::pair<std::vector<double>,std::vector<double> > > voxHitMap;

    for (int isp=0; isp<gAnalyzer->GetBTTTTracksScatterSize(); ++isp) {
        rAPPNUWSBTTTTracksScatter* tmpScPnt = gAnalyzer->GetBTTTTracksScatterAt(isp);
//        if ( tmpScPnt->GetOneTrackMatch() ) { continue; }

        TVector3 *scpos = tmpScPnt->Getpos();
        Double_t scposArr[3];
        scpos->GetXYZ(scposArr);

        bool checkIn=true;
        for (int isd=0; isd<3; ++isd) {
            checkIn = checkIn && (scposArr[isd]>=minVoxPos[isd]) && (scposArr[isd]<=maxVoxPos[isd]);
        }
        if (fDebug){
            std::cout<<"Point ";scpos->Print();std::cout<<std::endl;
            std::cout<<"In "<<checkIn<<std::endl;
        }
        if (checkIn) {

            rAPPNUWSRecoTracksTT *aTrkTT = gAnalyzer->GetRecoTracksTTAt(tmpScPnt->GetTrk1ID());
            TVector3 *posTT1 = aTrkTT->Getpos1();
            TVector3 dirTT1;
            dirTT1.SetMagThetaPhi( 1.0, aTrkTT->Gettheta1(), aTrkTT->Getphi1() );

            rAPPNUWSRecoTracksBT *aTrkBT = gAnalyzer->GetRecoTracksBTAt(tmpScPnt->GetTrk2ID());
            TVector3 *posBT0 = aTrkBT->Getpos0();
            TVector3 dirBT0;
            dirBT0.SetMagThetaPhi( 1.0, aTrkBT->Gettheta(), aTrkBT->Getphi() );

            TVector3 posTT1rot = convRot * (*posTT1);
            TVector3 dirTT1rot = convRot * dirTT1;
            TVector3 posBT1rot = convRot * (*posBT0);
            TVector3 dirBT1rot = convRot * dirBT0;

            extmutom::RayData tmpRayData;
            tmpRayData.ein = 0.0;
            tmpRayData.eout = 0.0;
            tmpRayData.pin = extmutom::Vector3(posTT1rot.X(),posTT1rot.Y(),posTT1rot.Z());
            tmpRayData.pout = extmutom::Vector3(posBT1rot.X(),posBT1rot.Y(),posBT1rot.Z());
            tmpRayData.din = extmutom::Vector3(dirTT1rot.X(),dirTT1rot.Y(),dirTT1rot.Z());
            tmpRayData.dout = extmutom::Vector3(dirBT1rot.X(),dirBT1rot.Y(),dirBT1rot.Z());

            if ( ((extmutom::MutoPoCA*) rec) -> getHasEnergy() ) {
                rAPPNUWSCSMTTHit *aTThit0 = gAnalyzer->GetCSMTTHitAt(aTrkTT->GethitindexAt(0));
                TVector3 momTThit0=0.001*TVector3(aTThit0->GetfEntranceMomX(),aTThit0->GetfEntranceMomY(),aTThit0->GetfEntranceMomZ()); // MeV -> GeV

                rAPPNUWSCSMBTHit *aBThit0 = gAnalyzer->GetCSMBTHitAt(aTrkBT->GethitindexAt(0));
                TVector3 momBThit0=0.001*TVector3(aBThit0->GetfEntranceMomX(),aBThit0->GetfEntranceMomY(),aBThit0->GetfEntranceMomZ()); // MeV -> GeV

                tmpRayData.ein = momTThit0.Mag();
                tmpRayData.eout = momBThit0.Mag();
            }

            data.push_back(tmpRayData);

            if (fDebug){
                //            std::cout<<"Point ";scpos->Print();std::cout<<std::endl;
                //            std::cout<<"In "<<checkIn<<std::endl;
            }
        }
    }
}

void rAPPNUWSTRecoExtMuonTomography::savePreTomography(extmutom::Image &img) {

    int fDebug=GetSP()->GetDebugLevel();

    gAnalyzer->SetPreTomographyInfoSize(1);

    rAPPNUWSPreTomographyInfo *tomInfo = gAnalyzer->GetPreTomographyInfoAt(0);
    tomInfo->SetminVolexPosCopy(3, minVoxPos);
    tomInfo->SetmaxVolexPosCopy(3, maxVoxPos);
    tomInfo->SetnVolexCopy(3, nVox);

    std::unordered_map< unsigned long, double > voxMap;

    int Id[3] = {-1,-1,-1};
    for (int ivx=0; ivx<nVox[0]; ++ivx) {
        for (int ivy=0; ivy<nVox[1]; ++ivy) {
            for (int ivz=0; ivz<nVox[2]; ++ivz) {
                Id[0]=ivx; Id[1]=ivy; Id[2]=ivz;
                unsigned long uid=IDdoUID(Id);
                voxMap[uid]=img(ivz,ivy,ivx);
            }
        }
    }

    gAnalyzer->SetPreTomographySize(voxMap.size());
    int iHit=0;
    for ( auto& voxData : voxMap)  {
        rAPPNUWSPreExtMuonTomography *iVxData = gAnalyzer->GetPreExtMuonTomographyAt(iHit);
        iVxData->SethitId(voxData.first);
        iVxData->SetlinDens(voxData.second);
        ++iHit;
    }

}
