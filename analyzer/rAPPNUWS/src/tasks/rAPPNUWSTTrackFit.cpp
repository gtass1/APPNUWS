////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// rAPPNUWSTTrackFit                                                          //
//                                                                            //
// Begin_Html <!--
/*-->

<!--*/
// --> End_Html
//                                                                            //
//                                                                            //
// Please note: The following information is only correct after executing     //
// the ROMEBuilder.                                                           //
//                                                                            //
// This task accesses the following folders :                                 //
//     GeantTrack                                                             //
//     CSMBTHit                                                               //
//     CSMTTHit                                                               //
//     RecoTracks                                                             //
//     RecoTracksBT                                                           //
//     RecoTracksTT                                                           //
//                                                                            //
// This task contains the following histgrams :                               //
//    HMomentum                                                               //
//    HXres                                                                   //
//    HYres                                                                   //
//    HZres                                                                   //
//                                                                            //
// The histograms/graph are created and saved automaticaly by the task.       //
//                                                                            //
// The following method can be used to get a handle of the histogram/graph :  //
//                                                                            //
// Get<Histogram/Graph Name>()                                                //
//                                                                            //
// For histogram/graph arrays use :                                           //
//                                                                            //
// Get<Histogram/Graph Name>At(Int_t index)                                   //
//                                                                            //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

/* Generated header file containing necessary includes                        */
#include "generated/rAPPNUWSTTrackFitGeneratedIncludes.h"

////////////////////////////////////////////////////////////////////////////////
/*  This header was generated by ROMEBuilder. Manual changes above the        *
 * following line will be lost next time ROMEBuilder is executed.             */
/////////////////////////////////////----///////////////////////////////////////

//#include "util/Geometry.h"
#include "tasks/rAPPNUWSTTrackFit.h"
#include "generated/rAPPNUWSAnalyzer.h"
#include "generated/rAPPNUWSRecoTracks.h"
#include "generated/rAPPNUWSRecoTracksTT.h"
#include "generated/rAPPNUWSRecoTracksBT.h"
#include "generated/rAPPNUWSGlobalSteering.h"
#include "ROMEiostream.h"
#include "TVector3.h"
#include "TMinuit.h"
#include "TClonesArray.h"
#include "TList.h"
#include "TMath.h"
#include "TF1.h"
#include "TRandom.h"

//#include "generated/rAPPNUWSDCHHit.h"
#include "generated/rAPPNUWSCSMTTHit.h"
#include "generated/rAPPNUWSCSMBTHit.h"
#include "generated/rAPPNUWSGeantTrack.h"

//#include "CellGeometryHandle.hh"
//#include "ROGeometryHandle.hh"
#include "CSMTtracker.hh"
#include "CSMBtracker.hh"
#include "CSMTTROGeometryHandle.hh"
#include "CSMBTROGeometryHandle.hh"

#include "ConstField.h"
#include "FieldManager.h"
#include <TGeoMaterialInterface.h>
#include <MaterialEffects.h>
#include "AbsTrackRep.h"
#include "RKTrackRep.h"
//#include "Track.h"
#include "RectangularFinitePlane.h"
#include <Tools.h>
#include "KalmanFitter.h"
#include "KalmanFitterRefTrack.h"
#include "DAF.h"
#include "KalmanFitterInfo.h"
#include <KalmanFittedStateOnPlane.h>
#include "Exception.h"
//#include "WireMeasurement.h"
//#include "WirePointMeasurement.h"
#include "SpacepointMeasurement.h"
#include "PlanarMeasurement.h"
#include <EventDisplay.h>

#include <TGeoGlobalMagField.h>
#include <TGeoManager.h>
#include <TROOT.h>
#include <memory>

using namespace genfit;

// uncomment if you want to include headers of all folders
//#include "rAPPNUWSAllFolders.h"

extern std::ostream& operator<<( std::ostream& ostr, const TVector3& f );//{return ostr<<f.X()<<" "<<f.Y()<<" "<<f.Z();}

ClassImp(rAPPNUWSTTrackFit)

using namespace std;

static const float sclfac=1;
//______________________________________________________________________________
void rAPPNUWSTTrackFit::Init() {

    fGeometry = GeometrySrvHndl::Instance();
    if(!fGeometry->GetCSMTTROChanHandle() || !fGeometry->GetCSMBTROChanHandle())
        fGeometry->makeDetectors();

    //init genfit
    TGeoManager::Import(gAnalyzer->GetGSP()->GetGeomGDMLfile());
    FieldManager::getInstance()->init(new ConstField(0,0,gAnalyzer->GetGSP()->GetBz()*10.)); //kGs
    MaterialEffects* mateff=MaterialEffects::getInstance();
    //mateff->setEnergyLossBetheBloch(true);
    //mateff->setNoiseBetheBloch(true);
    //mateff->setNoiseCoulomb(true);

    if ( GetSP()->GetDoDisplay() ) {
        // init event display
        genfit::EventDisplay* display = genfit::EventDisplay::getInstance();
    }

    //disable brems effect, as it is not correct for positron in genfit
    mateff->setEnergyLossBrems(false);
    mateff->setNoiseBrems(false);

    MaterialEffects::getInstance()->init(new TGeoMaterialInterface());

    //genfit::MaterialEffects::getInstance()->setNoEffects();

}

//______________________________________________________________________________
void rAPPNUWSTTrackFit::BeginOfRun() {
}

//______________________________________________________________________________
void rAPPNUWSTTrackFit::Event() {

    printf("\n rAPPNUWSTTrackFit::Event ***** Load event %lld ************************ \n",gAnalyzer->GetCurrentEventNumber());

    fBrHitsCSMTT=gAnalyzer->GetCSMTTHits();
    fBrHitsCSMBT=gAnalyzer->GetCSMBTHits();
    //  fBrHitsDC=gAnalyzer->GetDCHHits();
    fBrDataTrk=gAnalyzer->GetGeantTracks();

    fVert = TVector3(0.,0.,0.);

    MCFinder();

    if ( GetSP()->GetDoDisplay() ) {
        for (int it=0; it<ftracks.size(); ++it) {
            delete ftracks[it];
        }
        ftracks.clear();;
    }


    for(int i=0;i<gAnalyzer->GetRecoTracksTTSize();i++){
        rAPPNUWSRecoTracksTT *aTrkTT = gAnalyzer->GetRecoTracksTTAt(i);
        //    Fit(aTrk);
        Fit2TT(aTrkTT);
    }

    for(int i=0;i<gAnalyzer->GetRecoTracksBTSize();i++){
        rAPPNUWSRecoTracksBT *aTrkBT = gAnalyzer->GetRecoTracksBTAt(i);
        //    Fit(aTrk);
        Fit2BT(aTrkBT);
    }

    for(int i=0;i<gAnalyzer->GetRecoTracksSize();i++){
        rAPPNUWSRecoTracks *aTrk = gAnalyzer->GetRecoTracksAt(i);
        //    Fit(aTrk);
        Fit2(aTrk);
    }
    if ( GetSP()->GetDoDisplay() ) {
        genfit::EventDisplay::getInstance()->addEvent(ftracks);
    }


}

void rAPPNUWSTTrackFit::MCFinder(){
    int nprimary=0;
    std::vector<int> primaryID;
    primaryID.clear();
    Int_t nmctrack = fBrDataTrk->GetEntriesFast();
    for(int i=0;i<nmctrack;i++){
        rAPPNUWSGeantTrack* aMCTrack = ((rAPPNUWSGeantTrack*)fBrDataTrk->At(i));
        if(aMCTrack&&aMCTrack->GetfParentID()==0&&aMCTrack->GetfTrackID()>nprimary) {
            //nprimary=aMCTrack->GetfTrackID();
            primaryID.push_back(aMCTrack->GetfTrackID());
            ++nprimary;
        }
    }
    for(int i=0;i<nmctrack;i++){
        rAPPNUWSGeantTrack* aMCTrack = ((rAPPNUWSGeantTrack*)fBrDataTrk->At(i));
        if(aMCTrack->GetfParentID()>0&&aMCTrack->GetfTrackID()<=nprimary)
            std::cout<<"rAPPNUWSTTrackFit::MCFinder: Error in logic:first tracks are not only primary "<<aMCTrack->GetfTrackID()<<" "<<nprimary<<std::endl;
    }

    //  Int_t nhitsdch = fBrHitsDC->GetEntriesFast();
    //
    //  //sort by tof
    //  std::vector<std::vector<std::pair<double,int> > > hitvec(nprimary);
    //  for(int ihit=0;ihit<nhitsdch;ihit++){
    //    rAPPNUWSDCHHit *ahit = (rAPPNUWSDCHHit*) fBrHitsDC->At(ihit);
    //    //only hits beloging to primaries track
    //    int trkid=ahit->GetfTrkIDofHit();
    //    if (trkid <1 || trkid > nprimary) continue;
    //    hitvec[trkid-1].push_back(std::pair<double,int >(ahit->GetfGlobalTime(),ihit));
    //  }


    //Find hits of the primary tracks in the Top Tracker
    Int_t nhitsCSMTT = fBrHitsCSMTT->GetEntriesFast();

    //sort by tof
    std::vector<std::vector<std::pair<double,int> > > hitvec(nprimary);

    std::vector<std::vector<std::pair<double,int> > > hitvecTT(nprimary);
    for(int ihit=0;ihit<nhitsCSMTT;ihit++){
        rAPPNUWSCSMTTHit *ahit = (rAPPNUWSCSMTTHit*) fBrHitsCSMTT->At(ihit);
        //only hits beloging to primaries track
        int trkid=ahit->GetfTrkIDofHit();
        if (trkid <1 || trkid > nprimary) continue;
        hitvecTT[trkid-1].push_back(std::pair<double,int >(ahit->GetfGlobalTime(),ihit));
        hitvec[trkid-1].push_back(std::pair<double,int >(ahit->GetfGlobalTime(),ihit));
    }

    //Find hits of the primary tracks in the Bottom Tracker
    Int_t nhitsCSMBT = fBrHitsCSMBT->GetEntriesFast();

    std::vector<std::vector<std::pair<double,int> > > hitvecBT(nprimary);
    for(int ihit=0;ihit<nhitsCSMBT;ihit++){
        rAPPNUWSCSMBTHit *ahit = (rAPPNUWSCSMBTHit*) fBrHitsCSMBT->At(ihit);
        //only hits beloging to primaries track
        int trkid=ahit->GetfTrkIDofHit();
        if (trkid <1 || trkid > nprimary) continue;
        hitvecBT[trkid-1].push_back(std::pair<double,int >(ahit->GetfGlobalTime(),ihit));
        hitvec[trkid-1].push_back(std::pair<double,int >(ahit->GetfGlobalTime(),ihit+nhitsCSMTT));
    }

    std::cout<</*"nhits dch "<<nhitsdch<<*/" CSMTT "<<nhitsCSMTT<<" CSMBT "<<nhitsCSMBT<<std::endl;

    //Store identified tracks
    gAnalyzer->SetRecoTracksSize(nprimary);
    gAnalyzer->SetRecoTracksBTSize(nprimary);
    gAnalyzer->SetRecoTracksTTSize(nprimary);

    for(int i=0;i<nprimary;i++){
        //--------- global tack fitter  ---------
        rAPPNUWSRecoTracks *aTrk = gAnalyzer->GetRecoTracksAt(i);
        aTrk->SetTrkID(primaryID.at(i));
        aTrk->Getcov()->ResizeTo(6,6);

        unsigned int ntrkhits=hitvec[i].size();
        aTrk->Setnhits(ntrkhits);
        aTrk->SethitindexSize(ntrkhits);
        aTrk->SetdetidSize(ntrkhits);
        aTrk->SetIsFitted(false);
        aTrk->Getcov()->ResizeTo(6,6);

        //sort by tof
        std::sort(hitvec[i].begin(),hitvec[i].end());

        for(unsigned int ihit=0;ihit<ntrkhits;ihit++){
            int detid=hitvec[i][ihit].second<nhitsCSMTT?0:1;
            aTrk->SetdetidAt(ihit,detid);
            aTrk->SethitindexAt(ihit,hitvec[i][ihit].second/*-(detid>0?nhitsCSMTT:0)*/);
        }

        //--------- Top Tracker tack fitter  ---------
        rAPPNUWSRecoTracksTT *aTrkTT = gAnalyzer->GetRecoTracksTTAt(i);
        aTrkTT->SetTrkID(primaryID.at(i));
        aTrkTT->Getcov()->ResizeTo(6,6);

        unsigned int ntrkhitsTT=hitvecTT[i].size();
        aTrkTT->Setnhits(ntrkhitsTT);
        aTrkTT->SethitindexSize(ntrkhitsTT);
        aTrkTT->SetIsFitted(false);
        aTrkTT->Getcov()->ResizeTo(6,6);

        //sort by tof
        std::sort(hitvecTT[i].begin(),hitvecTT[i].end());

        for(unsigned int ihit=0;ihit<ntrkhitsTT;ihit++){
            aTrkTT->SethitindexAt(ihit,hitvecTT[i][ihit].second/*-(detid>0?nhitsdch:0)-(detid>1?nhitsCSMBT:0)*/);
        }

        //--------- Bottom Tracker tack fitter  ---------
        rAPPNUWSRecoTracksBT *aTrkBT = gAnalyzer->GetRecoTracksBTAt(i);
        aTrkBT->SetTrkID(primaryID.at(i));
        aTrkBT->Getcov()->ResizeTo(6,6);

        unsigned int ntrkhitsBT=hitvecBT[i].size();
        aTrkBT->Setnhits(ntrkhitsBT);
        aTrkBT->SethitindexSize(ntrkhitsBT);
        aTrkBT->SetIsFitted(false);
        aTrkBT->Getcov()->ResizeTo(6,6);

        //sort by tof
        std::sort(hitvecBT[i].begin(),hitvecBT[i].end());

        for(unsigned int ihit=0;ihit<ntrkhitsBT;ihit++){
            aTrkBT->SethitindexAt(ihit,hitvecBT[i][ihit].second/*-(detid>0?nhitsdch:0)-(detid>1?nhitsCSMBT:0)*/);
        }



        //
        //    //fit only first turn
        //    double trkdir_prev=1.;
        //    for(unsigned int ihit=0;ihit<ntrkhits;ihit++){
        //
        //      TVector3 xyz,k;
        //      int detid=hitvec[i][ihit].second<nhitsdch?0:(hitvec[i][ihit].second<nhitsdch+nhitsCSMBT?1:2);
        //
        //      if(detid==0){
        //        rAPPNUWSDCHHit *aHit = (rAPPNUWSDCHHit*) fBrHitsDC->At(hitvec[i][ihit].second);
        //
        //        xyz=TVector3(aHit->GetfEntranceX(),aHit->GetfEntranceY(),0);//aHit->GetfEntranceZ());
        //        k=TVector3(aHit->GetfEntranceMomX(),aHit->GetfEntranceMomY(),0);//aHit->GetfEntranceMomZ());
        //      }else if(detid==1){
        //        rAPPNUWSCSMBTHit *aHit = (rAPPNUWSCSMBTHit*) fBrHitsCSMBT->At(hitvec[i][ihit].second-nhitsdch);
        //
        //        xyz=TVector3(aHit->GetfEntranceX(),aHit->GetfEntranceY(),0);//aHit->GetfEntranceZ());
        //        k=TVector3(aHit->GetfEntranceMomX(),aHit->GetfEntranceMomY(),0);//aHit->GetfEntranceMomZ());
        //      }else{
        //        rAPPNUWSCSMTTHit *aHit = (rAPPNUWSCSMTTHit*) fBrHitsCSMTT->At(hitvec[i][ihit].second-nhitsdch-nhitsCSMBT);
        //
        //        xyz=TVector3(aHit->GetfEntranceX(),aHit->GetfEntranceY(),0);//aHit->GetfEntranceZ());
        //        k=TVector3(aHit->GetfEntranceMomX(),aHit->GetfEntranceMomY(),0);//aHit->GetfEntranceMomZ());
        //      }
        //
        //      double trkdir=xyz.Dot(k)/xyz.Mag()/k.Mag();
        //      if(trkdir_prev<=0&&trkdir>0){
        //        aTrk->Setnhits(ihit-1);
        //        break;
        //      }
        //      trkdir_prev=trkdir;
        //    }
    }

}


////______________________________________________________________________________
//void rAPPNUWSTTrackFit::StoreReconstructedTrack() {
//}

//______________________________________________________________________________
void rAPPNUWSTTrackFit::EndOfRun()
{
    if ( GetSP()->GetDoDisplay() ) {
        // open event display
        genfit::EventDisplay::getInstance()->open();
    }
}
//______________________________________________________________________________
void rAPPNUWSTTrackFit::Terminate() {
    if ( GetSP()->GetDoDisplay() ) {
        for (int it=0; it<ftracks.size(); ++it) {
            delete ftracks[it];
        }
        ftracks.clear();;
    }
}

//______________________________________________________________________________
//Bool_t rAPPNUWSTTrackFit::Fit(rAPPNUWSRecoTracks *aTrack) {
//    int fDebug=GetSP()->GetDebugLevel();//1;
//
//
//    int nhits = aTrack->Getnhits();
//
//    if (nhits < 6) {
//        printf(" ****  !!! Event not reconstructable: number of hits forr signal track less than 6!\n");
//        return false;
//    }
//
//    int trkid=0;
//    TVector3 xyzhit0,momhit0;
//    if(aTrack->GetdetidAt(0)==0){
//        rAPPNUWSDCHHit *ahit0 = (rAPPNUWSDCHHit*) fBrHitsDC->At(aTrack->GethitindexAt(0));
//        xyzhit0=0.1*TVector3(ahit0->GetfEntranceX(),ahit0->GetfEntranceY(),ahit0->GetfEntranceZ()); // mm -> cm
//        momhit0=0.001*TVector3(ahit0->GetfEntranceMomX(),ahit0->GetfEntranceMomY(),ahit0->GetfEntranceMomZ()); // MeV -> GeV
//        trkid=ahit0->GetfTrkIDofHit();
//    }else if(aTrack->GetdetidAt(0)==1){
//        rAPPNUWSCSMBTHit *ahit0 = (rAPPNUWSCSMBTHit*) fBrHitsCSMBT->At(aTrack->GethitindexAt(0));
//        xyzhit0=0.1*TVector3(ahit0->GetfEntranceX(),ahit0->GetfEntranceY(),ahit0->GetfEntranceZ()); // mm -> cm
//        momhit0=0.001*TVector3(ahit0->GetfEntranceMomX(),ahit0->GetfEntranceMomY(),ahit0->GetfEntranceMomZ()); // MeV -> GeV
//        trkid=ahit0->GetfTrkIDofHit();
//    }else{
//        rAPPNUWSCSMTTHit *ahit0 = (rAPPNUWSCSMTTHit*) fBrHitsCSMTT->At(aTrack->GethitindexAt(0));
//        xyzhit0=0.1*TVector3(ahit0->GetfEntranceX(),ahit0->GetfEntranceY(),ahit0->GetfEntranceZ()); // mm -> cm
//        momhit0=0.001*TVector3(ahit0->GetfEntranceMomX(),ahit0->GetfEntranceMomY(),ahit0->GetfEntranceMomZ()); // MeV -> GeV
//        trkid=ahit0->GetfTrkIDofHit();
//    }
//
//    //init values
//    TVector3 xyz0=xyzhit0;//fVert;
//    TVector3 pdir0=momhit0;
//    pdir0.SetMag(1.);
//    TVector3 pmom0=momhit0;//
//
//    //Do initialization of initial covariance matrix with sigma_p,sigma_angle, 1cm position
//    TMatrixDSym Cov(6); Cov.Zero();
//
//    Cov[0][0] = Cov[1][1] =Cov[2][2] = 0.1*0.1;//centimeters
//    Cov[3][3] = Cov[4][4] =Cov[5][5] = 0.001*0.001;//GeV
//
//    //-----------------------------------
//    //init positron track with parameters from first State Vector and predefined Covariance matrix
//    //-----------------------------------
//    int pdgid=11;
//    if(trkid<=fBrDataTrk->GetEntriesFast()&&trkid>0){
//        for(int i=0;i<fBrDataTrk->GetEntriesFast();i++){
//            rAPPNUWSGeantTrack* aMCTrack = ((rAPPNUWSGeantTrack*)fBrDataTrk->At(i));
//            if(aMCTrack->GetfTrackID()==trkid){
//                pdgid=aMCTrack->GetfPDGCode();
//                if(fDebug) std::cout<<"Primary track n. "<<i<<" has different PDG "<<pdgid<<std::endl;
//                break;
//            }
//        }
//    }
//
//    //
//    if(fDebug)
//        std::cout<<"set charge to pdgid ="<<pdgid<<std::endl;
//    AbsTrackRep *rep = new RKTrackRep(pdgid);
//    MeasuredStateOnPlane stateRef(rep);
//    rep->setPosMomCov(stateRef,xyz0,pmom0,Cov);
//    stateRef.setTime(0.);
//
//    //init genfit track from initial state
//    TVectorD seedState(6);
//    TMatrixDSym seedCov(6);
//    rep->get6DStateCov(stateRef, seedState, seedCov);
//    Track fitTrack(rep,seedState, seedCov);
//    fitTrack.setTimeSeed(0.);
//
//
//    //-----------------------------------------------
//    //fill hit information
//    //-----------------------------------------------
//    int nid=0;
//
//    //add vertex constrain
//    double sigmabeam=GetSP()->GetSigmaVtx();
//    if(sigmabeam>0){
//        TVectorD hitCoords(3);
//        TMatrixDSym hitCov(3);
//        for(int i=0;i<3;i++)
//            hitCoords(i)=gRandom->Gaus()*sigmabeam;
//        hitCov(0,0) = hitCov(1,1) = hitCov(2,2) = sigmabeam*sigmabeam;
//        genfit::SpacepointMeasurement* measurement = new genfit::SpacepointMeasurement(hitCoords, hitCov, 10, 100000, NULL);
//        fitTrack.insertMeasurement(measurement,nid++);
//        if(fDebug)
//            cout<<" add vertex constrain " <<hitCoords(0)<<" "<<hitCoords(1)<<" "<<hitCoords(2)<< " with +- "<<sigmabeam<<endl;
//    }
//
//    int ihit0dch=-1,ihit0CSMBT=-1,ihit0CSMTT=-1;
//    int nhitsdch=0,nhitsCSMBT=0,nhitsCSMTT=0;
//
//    for(int ihit=0;ihit<nhits;ihit++){
//
//        if(aTrack->GetdetidAt(ihit)==0){
//            if(ihit0dch<0) ihit0dch=0;
//            nhitsdch++;
//            rAPPNUWSDCHHit *ahit =(rAPPNUWSDCHHit*) fBrHitsDC->At(aTrack->GethitindexAt(ihit));
//
//            Int_t nwire=ahit->GetfCellId();
//
//            fGeometry->GetCellHandle()->SelectCellDet(nwire);
//            const CLHEP::Hep3Vector& mid   = fGeometry->GetCellHandle()->GetCellCenter();
//            const CLHEP::Hep3Vector& w     = fGeometry->GetCellHandle()->GetCellDirection();
//
//            TVector3 wire_pos(mid.x(),mid.y(),mid.z());
//            TVector3 wire_dir(w.x(),w.y(),w.z());
//
//            Double_t b_meas = ahit->GetfImpact();
//
//            //fill mesuarements
//            TVector3 p0 = 0.1*wire_pos;
//            TVector3 w_axis = wire_dir;
//            double wnorm=w_axis.Mag();
//            TVectorD hitCoords(8);
//            TMatrixDSym hitCov(8);
//            //fill wire ends
//            for(int i=0;i<3;i++){
//                hitCoords(i)=(p0+100*w_axis)(i);
//                hitCoords(i+3)=(p0-100*w_axis)(i);
//            }
//            //mesuared values dist,Z:
//            double sigmab=GetSP()->GetSigmaRPhi();
//            hitCoords(6) = b_meas*0.1+gRandom->Gaus()*sigmab;
//            //z mesuarment are relative to wire1 in direction of wire2
//            hitCoords(7) = 100.*wnorm;
//            hitCov(6,6) = sigmab*sigmab;
//            hitCov(7,7) = 100*100;
//            WireMeasurement *whit;
//            if(1==0){//use Z
//                whit=new WirePointMeasurement(hitCoords, hitCov,0,ihit,nullptr);
//            }else{
//                whit=new WireMeasurement(hitCoords, hitCov,0,ihit,nullptr);
//            }
//            whit->setLeftRightResolution(0);//1>0?1:-1);
//            fitTrack.insertMeasurement(whit,nid++);
//
//            if(fDebug>1){
//                std::cout<<"add "<<ihit<<" wire "<<nwire<<" xywire "<<p0.X()<<" "<<p0.Y()<<" "<<p0.z()
//	                 <<" bl "<<hitCoords(6)<<" sigma "<<sqrt(hitCov(6,6))<<" "<<sqrt(hitCov(7,7))<<" xyz "
//	                 <<0.1*ahit->GetfEntranceX()<<" "<<0.1*ahit->GetfEntranceY()<<" "<<0.1*ahit->GetfEntranceZ()<<" T "<<ahit->GetfGlobalTime()<<std::endl;
//            }
//        }else if(aTrack->GetdetidAt(ihit)==1){
//            if(ihit0CSMBT<0) ihit0CSMBT=0;
//            nhitsCSMBT++;
//            rAPPNUWSCSMBTHit *ahit =(rAPPNUWSCSMBTHit*) fBrHitsCSMBT->At(aTrack->GethitindexAt(ihit));
//
//            double pxlResolution=GetSP()->GetSigmaPxlVtx();
//            //double pxlResolution=GetSP()->GetSigmaPxlPreshower();
//            TMatrixDSym hitpxlCov(2);
//            hitpxlCov.UnitMatrix();
//            hitpxlCov *= pxlResolution*pxlResolution;
//
//            TVector3 pixel(0.1*ahit->GetfEntranceX(),0.1*ahit->GetfEntranceY(),0.1*ahit->GetfEntranceZ());
//            TVectorD hitCoords(2);
//            hitCoords[0] = gRandom->Gaus()*pxlResolution;
//            hitCoords[1] = gRandom->Gaus()*pxlResolution;
//            genfit::PlanarMeasurement* measurement = new genfit::PlanarMeasurement(hitCoords, hitpxlCov, 1, ihit, nullptr);
//            TVector3 vdir(-pixel.Y(),pixel.X(),0);vdir.SetMag(1);
//            measurement->setPlane(genfit::SharedPlanePtr(new genfit::DetPlane(TVector3(pixel.X(),pixel.Y(),pixel.Z()), vdir, TVector3(0,0,1))), 0);
//            fitTrack.insertMeasurement(measurement,nid++);
//            if(fDebug>1) {
//                cout<<" add "<<ihit<<" VTX mes "<<hitCoords[0]<<" "<<hitCoords[1]
//                                                                               <<" xyz "<<pixel.X()<<" "<<pixel.Y()<<" "<<pixel.Z()<< " with +- "<<pxlResolution<<" T "<<ahit->GetfGlobalTime()<<endl;
//                cout<<"U dir: "; vdir.Print();
//                cout<<"V dir: "; TVector3(0,0,1).Print();
//            }
//        }else{
//            if(ihit0CSMBT<0) ihit0CSMBT=0;
//            nhitsCSMTT++;
//            rAPPNUWSCSMTTHit *ahit =(rAPPNUWSCSMTTHit*) fBrHitsCSMTT->At(aTrack->GethitindexAt(ihit));
//
//            //double pxlResolution=GetSP()->GetSigmaPxlVtx();
//            double pxlResolution=GetSP()->GetSigmaPxlPreshower();
//            TMatrixDSym hitpxlCov(2);
//            hitpxlCov.UnitMatrix();
//            hitpxlCov *= pxlResolution*pxlResolution;
//
//            TVector3 pixel(0.1*ahit->GetfEntranceX(),0.1*ahit->GetfEntranceY(),0.1*ahit->GetfEntranceZ());
//            TVectorD hitCoords(2);
//            hitCoords[0] = gRandom->Gaus()*pxlResolution;
//            hitCoords[1] = gRandom->Gaus()*pxlResolution;
//            genfit::PlanarMeasurement* measurement = new genfit::PlanarMeasurement(hitCoords, hitpxlCov, 2, ihit, nullptr);
//            TVector3 vdir(-pixel.Y(),pixel.X(),0);vdir.SetMag(1);
//            measurement->setPlane(genfit::SharedPlanePtr(new genfit::DetPlane(TVector3(pixel.X(),pixel.Y(),pixel.Z()), vdir, TVector3(0,0,1))), 0);
//            fitTrack.insertMeasurement(measurement,nid++);
//            if(fDebug>1)
//                cout<<" add "<<ihit<<" CSMTT mes "<<hitCoords[0]<<" "<<hitCoords[1]
//                                                                                 <<" xyz "<<pixel.X()<<" "<<pixel.Y()<<" "<<pixel.Z()<< " with +- "<<pxlResolution<<" T "<<ahit->GetfGlobalTime()<<endl;
//
//        }
//    }
//
//
//
//    // ---- end of hit info filling ------------------------
//
//
//    //  assert(fitTrack.checkConsistency());
//    fitTrack.checkConsistency();
//    genfit::FitStatus* fitStatus=fitTrack.getFitStatus(rep);
//    if(fDebug){
//        std::cout<<" init chi2 "<<fitStatus->getChi2()<<" nfailed "<<fitStatus->getNFailedPoints()
//                     <<" P= "<<rep->getMomMag(stateRef)*rep->getCharge(stateRef)<<" +- "<<sqrt(rep->getMomVar(stateRef))
//                     <<" nhits "<<nid<<" from "<<nhits<<" dch "<<nhitsdch<<" CSMBT "<<nhitsCSMBT<<" CSMTT "<<nhitsCSMTT<<std::endl;
//        std::cout<<"init state "<<xyz0<<" "<<pmom0<<endl;
//    }
//
//    //choose different fitter
//    genfit::AbsKalmanFitter* fitter = 0;
//    switch(0/*GetSP()->GetKalmanType()*/){
//    case 0:
//        fitter=new DAF();
//        break;
//    case 1:
//        fitter=new KalmanFitterRefTrack(20);
//        break;
//    case 2:
//        fitter=new KalmanFitter(20);
//        break;
//    }
//    /*
//  if(GetSP()->GetKalmanType()>0){
//    //use LR from patter recognition in case of usual KalmanFitter
//    fitter->setMultipleMeasurementHandling(genfit::weightedClosestToPredictionWire);
//  }*/
//
//    if(kDebug>20){
//        fitter->setDebugLvl(10);
//        rep->setDebugLvl(10);
//    }
//
//    //-----------------------------------
//    // FIT IT
//    //-----------------------------------
//    //cout<<"-----------1-------------"<<endl;
//    try{
//        fitter->processTrack(&fitTrack);
//    }catch(Exception& e){
//        if(fDebug) std::cout<<"on fitting "<<e.what()<<std::endl;
//    }
//    //cout<<"-----------2-------------"<<endl;
//    fitStatus=fitTrack.getFitStatus(rep);
//    bool fitstatus=fitStatus->isFitConverged()&&(fitStatus->getNFailedPoints()==0);
//    if(fDebug) fitStatus->Print();
//    //cout<<"-----------3-------------"<<endl;
//
//
//    TVector3 pos,mom;
//    TMatrixDSym cov(6);
//    TVector3 pos2,mom2;
//    TMatrixDSym cov2(6);
//    double pmom=0;
//    double tof=0;
//    double sigmap=0.;
//
//    //-----------------------------------
//    // fill info from first hit
//    //-----------------------------------
//
//    try{
//        const MeasuredStateOnPlane& stFirst=fitTrack.getFittedState();
//        pmom=rep->getMomMag(stFirst)*rep->getCharge(stFirst);
//        stFirst.getPosMomCov(pos,mom,cov);
//        tof=stFirst.getTime();
//    }catch(Exception& e){
//        if(fDebug) std::cout<<"on getting state "<<e.what()<<std::endl;
//    }
//
//
//    if(fDebug)
//        std::cout<<" chi2 "<<fitStatus->getChi2()<<" nfailed "<<fitStatus->getNFailedPoints()
//        <<" P= "<<pmom<<" fitok="<<fitstatus<<std::endl;
//
//    if(fDebug){std::cout<<"fitted xyz "<<pos<<" mom "<<mom<<endl;}
//
//    //-----------------------------------
//    //set states on hits
//    //-----------------------------------
//
//    unsigned int numhits = fitTrack.getNumPoints();
//
//    int ngoodhits=0;
//    int ngoodhitsdch=0,ngoodhitsCSMBT=0,ngoodhitsCSMTT=0;
//    double sumddist=0;
//
//    aTrack->SetStateVectorSize(nhits);
//    aTrack->GetSkipped().resize(nhits,true);
//
//    if(fitstatus){
//        try{
//            for(unsigned int jhit=0;jhit<numhits;jhit++){
//                TrackPoint* point = fitTrack.getPoint(jhit);
//                int ihit=point->getRawMeasurement(0)->getHitId();
//                int detid=point->getRawMeasurement(0)->getDetId();
//                //skip virtual hit
//                //        if(ihit>=1000) continue;
//
//                //skip point without fitted information
//                if(!point->hasFitterInfo(rep)) continue;
//
//                KalmanFitterInfo* fi = static_cast<KalmanFitterInfo*>(point->getFitterInfo(rep));
//                //get weights for LR combinations
//                std::vector<double> dafWeights = fi->getWeights();
//
//                //maximum weigth in fitting from LR positions
//                int imaxdaf=std::distance(dafWeights.begin(),
//                        std::max_element(dafWeights.begin(),dafWeights.end()));
//                double maxdaf=dafWeights[imaxdaf];
//
//
//                //fill histogram with final chi2 per hit
//                const MeasurementOnPlane& residual = fi->getResidual(imaxdaf, false, false);
//                const TVectorD& resid(residual.getState());
//
//                //dont fill StateVector forr skipped hits during fitting(in normal case hit must have weight=1.)
//                if(maxdaf<0.5) {
//                    if(fDebug>9) std::cout<<"skip point "<<endl;
//                    continue;
//                }
//
//                //fill biased best StateVector on hit
//                // (averaged from forward-backward propagation)
//                const MeasuredStateOnPlane& state=fi->getFittedState(true);
//                state.getPosMomCov(pos,mom,cov);
//
//                //unbiased
//                const MeasuredStateOnPlane& state2=fi->getFittedState(false);
//                state2.getPosMomCov(pos2,mom2,cov2);
//
//                if(detid==0){
//                    //average T0 shift over hits
//                    sumddist+=resid(0)*(imaxdaf?1:-1);
//                    ngoodhitsdch++;
//                }else if(detid==1){
//                    ngoodhitsCSMBT++;
//                }else if(detid==2){
//                    ngoodhitsCSMTT++;
//                }
//
//                if(detid<10){ //wire or CSMBT or CSMTT hit
//                    aTrack->SetSkippedAt(ihit,false);
//                    *aTrack->GetStateVectorAt(ihit)=pos;
//                    ngoodhits++;
//                    if(detid==0){
//                        rAPPNUWSDCHHit *ahit = (rAPPNUWSDCHHit*) fBrHitsDC->At(aTrack->GethitindexAt(ihit));
//                        if(fDebug>9)
//                            cout<<detid<<" "<<ihit<<" track aver "<<state.getState()(3)<<" mes "<<0.1*ahit->GetfImpact()<<" dR not biased "<<resid(0)
//                            <<" biased "<<0.1*ahit->GetfImpact()-fabs(state.getState()(3))<<" trk xyz "<<pos<<" mom "<<mom.Y()<<endl;
//                        GetHResidualUnbiased()->Fill(10*fabs(state.getState()(3)),10*resid(0));
//                        GetHResidualBiased()->Fill(10*fabs(state.getState()(3)),ahit->GetfImpact()-10*fabs(state.getState()(3)));
//                    }else if(detid==1){
//                        rAPPNUWSCSMBTHit *ahit = (rAPPNUWSCSMBTHit*) fBrHitsCSMBT->At(aTrack->GethitindexAt(ihit));
//                        if(fDebug>9)
//                            cout<<detid<<" "<<ihit<<" track aver "<<state.getState()(3)<<" "<<state.getState()(4)<<" exact mes 0 0 dy,dz not biased "<<resid(0)<<" "<<resid(1)
//                            <<" trk xyz "<<pos<<" mom "<<mom.Y()<<endl;
//                    }else if(detid==2){
//                        rAPPNUWSCSMTTHit *ahit = (rAPPNUWSCSMTTHit*) fBrHitsCSMTT->At(aTrack->GethitindexAt(ihit));
//                        if(fDebug>9)
//                            cout<<detid<<" "<<ihit<<" track aver "<<state.getState()(3)<<" "<<state.getState()(4)<<" exact mes 0 0 dy,dz not biased "<<resid(0)<<" "<<resid(1)
//                            <<" trk xyz "<<pos<<" mom "<<mom.Y()<<endl;
//                    }
//                }
//                // state.Print();
//                // cov.Print();
//                // state2.Print();
//                // cov2.Print();
//                if(ihit==aTrack->GethitindexAt(0))
//                    if(IsHMomentumActive()) GetHMomentum()->Fill(pmom0.Mag(),mom.Mag()/pmom0.Mag()-1);
//                if(fDebug>9) {
//                    std::cout<<jhit<<" detid "<<detid<<" id "<<ihit<<" at hit "<<pos<<" "<<mom<<endl;
//                }
//            }
//        }catch(Exception& e){
//            if(fDebug) std::cout<<"on getting points "<<e.what()<<std::endl;
//            fitstatus=false;
//        }
//        sumddist/=ngoodhitsdch;
//        if(fDebug) std::cout<<" filtrated hits "<<numhits-ngoodhits<<" average ddist "<<sumddist/(0.4/150e-9)<<std::endl;
//    }
//
//
//    //-----------------------------------
//    //propagate to target
//    //-----------------------------------
//    if(fitstatus){
//
//        //force backward propagation(will be working forr only finite plane
//        rep->setPropDir(-1);
//        //take first fitted point
//        TrackPoint* tp = fitTrack.getPointWithFitterInfo(0);
//        if (tp == NULL) {std::cout << "Track has no TrackPoint with fitterInfo!(but fitstatus ok?)"<<std::endl;}
//        KalmanFitterInfo* fi = static_cast<KalmanFitterInfo*>(tp->getFitterInfo(rep));
//        MeasuredStateOnPlane state;
//
//        //extrapolate rep to target plane
//        bool isattarget=true;
//        try{
//            state=fi->getFittedState(true);
//            rep->extrapolateToLine(state,TVector3(0,0,0),TVector3(0,0,1));
//        }catch(Exception& e){
//            if(fDebug) std::cout<<"on extrapolation to beam line "<<e.what()<<std::endl;
//            isattarget=false;
//        }
//        double tof_target=1e9;
//        if(isattarget){
//            tof_target=state.getTime();
//            state.getPosMomCov(pos,mom,cov);
//            double momrec=mom.Mag();
//            sigmap=momrec*momrec*TMath::Sqrt(state.getCov()(0,0));
//
//        }
//        if(fDebug)
//            std::cout<<"vertex chi2 "<<fitStatus->getChi2()<<" ndf "<<fitStatus->getNdf()
//            <<" nhits "<<nhits<<" dch "<<nhitsdch<<" CSMBT "<<nhitsCSMBT<<" CSMTT "<<nhitsCSMTT<<" nfailed "<<fitStatus->getNFailedPoints()
//            <<" P= "<<mom.Mag()*rep->getCharge(state)<<" +- "<<sigmap<<" fitok="<<fitstatus
//            <<" pos "<<pos<<" mom "<<mom<<std::endl;
//    }
//
//    aTrack->Setx0(pos.X()*10);
//    aTrack->Seterr_x0(sqrt(cov(0,0))*10);
//    aTrack->Sety0(pos.Y()*10);
//    aTrack->Seterr_y0(sqrt(cov(1,1))*10);
//    aTrack->Setz0(pos.Z()*10);
//    aTrack->Seterr_z0(sqrt(cov(2,2))*10);
//    aTrack->Settheta(mom.Theta());
//    aTrack->Seterr_theta(0.);
//    aTrack->Setphi(mom.Phi());
//    aTrack->Seterr_phi(0.);
//    aTrack->SetMomentum(mom.Mag());
//    aTrack->SetErr_Momentum(sigmap);
//    aTrack->Setmom(mom);
//    aTrack->Getcov()->ResizeTo(6,6);
//    aTrack->Setcov(cov);
//
//    //fill final information
//    aTrack->Setnhits(nhits);
//    aTrack->Setnhitsdch(nhitsdch);
//    aTrack->SetnhitsCSMBT(nhitsCSMBT);
//    aTrack->SetnhitsCSMTT(nhitsCSMTT);
//    aTrack->Setchi2(fitStatus->getChi2());
//    aTrack->Setdof(fitStatus->getNdf());
//    aTrack->Setngoodhits(ngoodhits);
//    aTrack->Setngoodhitsdch(ngoodhitsdch);
//    aTrack->SetngoodhitsCSMBT(ngoodhitsCSMBT);
//    aTrack->SetngoodhitsCSMTT(ngoodhitsCSMTT);
//    aTrack->SetIsFitted(fitstatus);
//
//
//    delete fitter;
//
//    return true;
//}

//______________________________________________________________________________
Bool_t rAPPNUWSTTrackFit::Fit2(TObject *tmpTrack) {
    int fDebug=GetSP()->GetDebugLevel();//1;

    int trkid=0;
    TVector3 xyzhit0,momhit0;
    int nhits = 0;

    rAPPNUWSRecoTracks *aTrack = (rAPPNUWSRecoTracks *)tmpTrack;

    nhits = aTrack->Getnhits();
    if (nhits < 5) {
        printf(" ****  !!! Event not reconstructable: number of hits for TT and BT signal track less than 5!\n");
        return false;
    }

    if (aTrack->GetdetidAt(0)==0) {

        rAPPNUWSCSMTTHit *ahit0 = (rAPPNUWSCSMTTHit*) fBrHitsCSMTT->At(aTrack->GethitindexAt(0));
        xyzhit0=sclfac*TVector3(ahit0->GetfEntranceX(),ahit0->GetfEntranceY(),ahit0->GetfEntranceZ()); // mm -> cm
        momhit0=0.001*TVector3(ahit0->GetfEntranceMomX(),ahit0->GetfEntranceMomY(),ahit0->GetfEntranceMomZ()); // MeV -> GeV
        trkid=ahit0->GetfTrkIDofHit();

    } else if (aTrack->GetdetidAt(0)==1) {

        int hitInd = aTrack->GethitindexAt(0)-fBrHitsCSMTT->GetEntriesFast();
        rAPPNUWSCSMBTHit *ahit0 = (rAPPNUWSCSMBTHit*) fBrHitsCSMBT->At(hitInd);
        xyzhit0=sclfac*TVector3(ahit0->GetfEntranceX(),ahit0->GetfEntranceY(),ahit0->GetfEntranceZ()); // mm -> cm
        momhit0=0.001*TVector3(ahit0->GetfEntranceMomX(),ahit0->GetfEntranceMomY(),ahit0->GetfEntranceMomZ()); // MeV -> GeV
        trkid=ahit0->GetfTrkIDofHit();

    }

    //init values
    TVector3 xyz0=xyzhit0;//fVert;
    TVector3 pdir0=momhit0;
    pdir0.SetMag(1.);
    TVector3 pmom0=momhit0;//

    //Do initialization of initial covariance matrix with sigma_p,sigma_angle, 1cm position
    TMatrixDSym Cov(6); Cov.Zero();

    Cov[0][0] = Cov[1][1] =Cov[2][2] = sclfac*sclfac;//centimeters
    Cov[3][3] = Cov[4][4] =Cov[5][5] = 0.001*0.001;//GeV

    //-----------------------------------
    //init positron track with parameters from first State Vector and predefined Covariance matrix
    //-----------------------------------
    int pdgid=13;
    if(trkid<=fBrDataTrk->GetEntriesFast()&&trkid>0){
        for(int i=0;i<fBrDataTrk->GetEntriesFast();i++){
            rAPPNUWSGeantTrack* aMCTrack = ((rAPPNUWSGeantTrack*)fBrDataTrk->At(i));
            if(aMCTrack->GetfTrackID()==trkid){
                if (pdgid!=aMCTrack->GetfPDGCode()) {
                    pdgid=aMCTrack->GetfPDGCode();
                    if(fDebug) std::cout<<"Primary track n. "<<i<<" has different PDG "<<pdgid<<std::endl;
                    break;
                }
            }
        }
    }

    //
    if(fDebug)
        std::cout<<"set charge to pdgid ="<<pdgid<<std::endl;
    AbsTrackRep *rep = new RKTrackRep(pdgid);
    MeasuredStateOnPlane stateRef(rep);
    rep->setPosMomCov(stateRef,xyz0,pmom0,Cov);
    stateRef.setTime(0.);

    //init genfit track from initial state
    TVectorD seedState(6);
    TMatrixDSym seedCov(6);
    rep->get6DStateCov(stateRef, seedState, seedCov);
    Track fitTrack(rep,seedState, seedCov);
    fitTrack.setTimeSeed(0.);


    //-----------------------------------------------
    //fill hit information
    //-----------------------------------------------
    int nid=0;

//    //add vertex constrain
//    double sigmabeam=GetSP()->GetSigmaVtx();
//    if(sigmabeam>0){
//        TVectorD hitCoords(3);
//        TMatrixDSym hitCov(3);
//        for(int i=0;i<3;i++)
//            hitCoords(i)=gRandom->Gaus()*sigmabeam;
//        hitCov(0,0) = hitCov(1,1) = hitCov(2,2) = sigmabeam*sigmabeam;
//        genfit::SpacepointMeasurement* measurement = new genfit::SpacepointMeasurement(hitCoords, hitCov, 10, 100000, NULL);
//        fitTrack.insertMeasurement(measurement,nid++);
//        if(fDebug)
//            cout<<" add vertex constrain " <<hitCoords(0)<<" "<<hitCoords(1)<<" "<<hitCoords(2)<< " with +- "<<sigmabeam<<endl;
//    }

    int /*ihit0dch=-1,*/ihit0CSMBT=-1,ihit0CSMTT=-1;
    int /*nhitsdch=0,*/nhitsCSMBT=0,nhitsCSMTT=0;

    for(int ihit=0;ihit<nhits;ihit++){

        rAPPNUWSRecoTracks *aTrack = (rAPPNUWSRecoTracks *)tmpTrack;

        if (aTrack->GetdetidAt(ihit)==0) {

            rAPPNUWSCSMTTHit *ahit = (rAPPNUWSCSMTTHit*) fBrHitsCSMTT->At(aTrack->GethitindexAt(ihit));
            addTThit (ahit, ihit, ihit0CSMTT, nhitsCSMTT, fitTrack, nid);

        } else if (aTrack->GetdetidAt(ihit)==1) {

            int hitInd = aTrack->GethitindexAt(ihit)-fBrHitsCSMTT->GetEntriesFast();
            rAPPNUWSCSMBTHit *ahit = (rAPPNUWSCSMBTHit*) fBrHitsCSMBT->At(hitInd);
            addBThit (ahit, ihit, ihit0CSMBT, nhitsCSMBT, fitTrack, nid);

        }

    }

    // ---- end of hit info filling ------------------------


    //  assert(fitTrack.checkConsistency());
    fitTrack.checkConsistency();
    genfit::FitStatus* fitStatus=fitTrack.getFitStatus(rep);
    if(fDebug){
        std::cout<<" init chi2 "<<fitStatus->getChi2()<<" nfailed "<<fitStatus->getNFailedPoints()
                     <<" P= "<<rep->getMomMag(stateRef)*rep->getCharge(stateRef)<<" +- "<<sqrt(rep->getMomVar(stateRef))
                     <<" nhits "<<nid<<" from "<<nhits/*<<" dch "<<nhitsdch*/<<" CSMBT "<<nhitsCSMBT<<" CSMTT "<<nhitsCSMTT<<std::endl;
        std::cout<<"init state ";xyz0.Print();std::cout<<" ";pmom0.Print();std::cout<<endl;
    }

    //choose different fitter
    genfit::AbsKalmanFitter* fitter = 0;
    switch(0/*GetSP()->GetKalmanType()*/){
    case 0:
        fitter=new DAF();
        break;
    case 1:
        fitter=new KalmanFitterRefTrack(20);
        break;
    case 2:
        fitter=new KalmanFitter(20);
        break;
    }
    /*
  if(GetSP()->GetKalmanType()>0){
    //use LR from patter recognition in case of usual KalmanFitter
    fitter->setMultipleMeasurementHandling(genfit::weightedClosestToPredictionWire);
  }*/

    if(fDebug>20){
        fitter->setDebugLvl(10);
        rep->setDebugLvl(10);
    }

    //-----------------------------------
    // FIT IT
    //-----------------------------------

    try{
        fitter->processTrack(&fitTrack);
    }catch(Exception& e){
        if(fDebug) std::cout<<"on fitting "<<e.what()<<std::endl;
    }
    fitStatus=fitTrack.getFitStatus(rep);
    bool fitstatus=fitStatus->isFitConverged()&&(fitStatus->getNFailedPoints()==0);
    if(fDebug) fitStatus->Print();


    TVector3 pos,mom;
    TMatrixDSym cov(6);
    TVector3 pos1,mom1;
    TMatrixDSym cov1(6);
    double pmom=0;
    double tof=0;
    double sigmap=0.;

    //-----------------------------------
    // fill info from first hit
    //-----------------------------------

    try{
        const MeasuredStateOnPlane& stFirst=fitTrack.getFittedState();
        pmom=rep->getMomMag(stFirst)*rep->getCharge(stFirst);
        stFirst.getPosMomCov(pos,mom,cov);
        tof=stFirst.getTime();
    }catch(Exception& e){
        if(fDebug) std::cout<<"on getting state "<<e.what()<<std::endl;
    }


    if(fDebug) {
        std::cout<<" chi2 "<<fitStatus->getChi2()<<" nfailed "<<fitStatus->getNFailedPoints()
        <<" P= "<<pmom<<" fitok="<<fitstatus<<std::endl;
    }

    if(fDebug){std::cout<<"fitted xyz ";pos.Print();std::cout<<" mom ";mom.Print();std::cout<<endl;}

    //-----------------------------------
    //set states on hits
    //-----------------------------------

    unsigned int numhits = fitTrack.getNumPoints();

    int ngoodhits=0;
    int /*ngoodhitsdch=0,*/ngoodhitsCSMBT=0,ngoodhitsCSMTT=0;
//    double sumddist=0;

    aTrack->SetStateVectorSize(nhits);
    aTrack->GetSkipped().resize(nhits,true);

    if(fitstatus){
        try{

            for(unsigned int jhit=0;jhit<numhits;jhit++){
                TrackPoint* point = fitTrack.getPoint(jhit);
                int ihit=point->getRawMeasurement(0)->getHitId();
                int idetid=point->getRawMeasurement(0)->getDetId();
                //skip virtual hit
                //        if(ihit>=1000) continue;

                //skip point without fitted information
                if(!point->hasFitterInfo(rep)) continue;

                KalmanFitterInfo* fi = static_cast<KalmanFitterInfo*>(point->getFitterInfo(rep));
                //get weights for LR combinations
                std::vector<double> dafWeights = fi->getWeights();

                //maximum weigth in fitting from LR positions
                int imaxdaf=std::distance(dafWeights.begin(),
                        std::max_element(dafWeights.begin(),dafWeights.end()));
                double maxdaf=dafWeights[imaxdaf];


                //fill histogram with final chi2 per hit
                const MeasurementOnPlane& residual = fi->getResidual(imaxdaf, false, false);
                const TVectorD& resid(residual.getState());

                //dont fill StateVector forr skipped hits during fitting(in normal case hit must have weight=1.)
                if(maxdaf<0.5) {
                    if(fDebug>9) std::cout<<"skip point "<<endl;
                    continue;
                }

                //fill biased best StateVector on hit
                // (averaged from forward-backward propagation)
                const MeasuredStateOnPlane& state=fi->getFittedState(true);
                state.getPosMomCov(pos,mom,cov);

//                //unbiased
//                const MeasuredStateOnPlane& state2=fi->getFittedState(false);
//                state2.getPosMomCov(pos2,mom2,cov2);

                /*if(idetid==0){
                    //average T0 shift over hits
                    sumddist+=resid(0)*(imaxdaf?1:-1);
                    ngoodhitsdch++;
                }else*/
                if(idetid==0){
                    ngoodhitsCSMTT++;
                }else if(idetid==1){
                    ngoodhitsCSMBT++;
                }

                if(idetid<10){ //CSMTT or CSMBT hit
                    aTrack->SetSkippedAt(ihit,false);
                    *aTrack->GetStateVectorAt(ihit)=pos;
                    ngoodhits++;
                    /*if(idetid==0){
                        rAPPNUWSDCHHit *ahit = (rAPPNUWSDCHHit*) fBrHitsDC->At(aTrack->GethitindexAt(ihit));
                        if(fDebug>9)
                            cout<<idetid<<" "<<ihit<<" track aver "<<state.getState()(3)<<" mes "<<0.1*ahit->GetfImpact()<<" dR not biased "<<resid(0)
                            <<" biased "<<0.1*ahit->GetfImpact()-fabs(state.getState()(3))<<" trk xyz "<<pos<<" mom "<<mom.Y()<<endl;
                        GetHResidualUnbiased()->Fill(10*fabs(state.getState()(3)),10*resid(0));
                        GetHResidualBiased()->Fill(10*fabs(state.getState()(3)),ahit->GetfImpact()-10*fabs(state.getState()(3)));
                    }else*/
                    if(idetid==0){
                        rAPPNUWSCSMTTHit *ahit = (rAPPNUWSCSMTTHit*) fBrHitsCSMTT->At(aTrack->GethitindexAt(ihit));
                        if(fDebug>9) {
                            cout<<idetid<<" "<<ihit<<" track aver "<<state.getState()(3)<<" "<<state.getState()(4)<<" exact mes 0 0 dy,dz not biased "<<resid(0)<<" "<<resid(1)
                            <<" trk xyz ";pos.Print();std::cout<<" mom "<<mom.Y()<<endl;
                        }
                    } else if(idetid==1){
                        rAPPNUWSCSMBTHit *ahit = (rAPPNUWSCSMBTHit*) fBrHitsCSMBT->At(aTrack->GethitindexAt(ihit));
                        if(fDebug>9) {
                            cout<<idetid<<" "<<ihit<<" track aver "<<state.getState()(3)<<" "<<state.getState()(4)<<" exact mes 0 0 dy,dz not biased "<<resid(0)<<" "<<resid(1)
                            <<" trk xyz ";pos.Print();std::cout<<" mom "<<mom.Y()<<endl;
                        }
                    }
                }
                // state.Print();
                // cov.Print();
                // state2.Print();
                // cov2.Print();
//                if(ihit==aTrack->GethitindexAt(0))
//                    if(IsHMomentumActive()) GetHMomentum()->Fill(pmom0.Mag(),mom.Mag()/pmom0.Mag()-1);
                if(fDebug>9) {
                    std::cout<<jhit<<" idetid "<<idetid<<" id "<<ihit<<" at hit ";pos.Print();std::cout<<" ";mom.Print();std::cout<<endl;
                }
            }
        }catch(Exception& e){
            if(fDebug) std::cout<<"on getting points "<<e.what()<<std::endl;
            fitstatus=false;
        }
//        sumddist/=ngoodhitsdch;
        if(fDebug) std::cout<<" filtrated hits "<<numhits-ngoodhits/*<<" average ddist "<<sumddist/(0.4/150e-9)*/<<std::endl;
    }


    //-----------------------------------
    //propagate to
    //-----------------------------------
    if(fitstatus){

        //force backward propagation(will be working forr only finite plane
        rep->setPropDir(0);
        //take first fitted point
        TrackPoint* tp = fitTrack.getPointWithFitterInfo(0);
        if (tp == NULL) {std::cout << "Track has no TrackPoint with fitterInfo!(but fitstatus ok?)"<<std::endl;}
        KalmanFitterInfo* fi = static_cast<KalmanFitterInfo*>(tp->getFitterInfo(rep));
        MeasuredStateOnPlane state;

        bool isUp=true;
        try{
            state=fi->getFittedState(true);
            rep->extrapolateToLine(state,TVector3(0,fGeometry->GetCSMTtracker()->distOut()*sclfac,0),TVector3(0,0,1));
        }catch(Exception& e){
            if(fDebug) std::cout<<"on extrapolation to center line "<<e.what()<<std::endl;
            isUp=false;
        }
//        double tof_target=1e9;
        if(isUp){
//            tof_target=state.getTime();
            state.getPosMomCov(pos,mom,cov);
            double momrec=mom.Mag();
            sigmap=momrec*momrec*TMath::Sqrt(state.getCov()(0,0));

        }
        if(fDebug) {
            std::cout<<"vertex chi2 "<<fitStatus->getChi2()<<" ndf "<<fitStatus->getNdf()
            <<" nhits "<<nhits/*<<" dch "<<nhitsdch*/<<" CSMTT "<<nhitsCSMTT<<" nfailed "<<fitStatus->getNFailedPoints()
            <<" P= "<<mom.Mag()*rep->getCharge(state)<<" +- "<<sigmap<<" fitok="<<fitstatus
            <<" pos "; pos.Print();
            std::cout<<" mom "; mom.Print();
            //std::cout<<std::endl;
        }

        //extrapolate to Bottom face of the Bottom Tracker
        rep->setPropDir(0);
        bool isBt=true;
        try{
            state=fi->getFittedState(true);
            rep->extrapolateToLine(state,TVector3(0,fGeometry->GetCSMBtracker()->distIn()*sclfac,0),TVector3(0,0,1));
        }catch(Exception& e){
            if(fDebug) std::cout<<"on extrapolation to center line "<<e.what()<<std::endl;
            isBt=false;
        }
//        double tof_target=1e9;
        if(isBt){
//            tof_target=state.getTime();
            state.getPosMomCov(pos1,mom1,cov1);
        }

    }

    aTrack->Setx0(pos.X()/sclfac);
    aTrack->Seterr_x0(sqrt(cov(0,0))/sclfac);
    aTrack->Sety0(pos.Y()/sclfac);
    aTrack->Seterr_y0(sqrt(cov(1,1))/sclfac);
    aTrack->Setz0(pos.Z()/sclfac);
    aTrack->Seterr_z0(sqrt(cov(2,2))/sclfac);
    aTrack->Settheta(mom.Theta());
    aTrack->Seterr_theta(0.);
    aTrack->Setphi(mom.Phi());
    aTrack->Seterr_phi(0.);
    aTrack->SetMomentum(mom.Mag());
    aTrack->SetErr_Momentum(sigmap);
    aTrack->Setmom(mom);
    aTrack->Getcov()->ResizeTo(6,6);
    aTrack->Setcov(cov);

    aTrack->Setx1(pos1.X()/sclfac);
    aTrack->Seterr_x1(sqrt(cov1(0,0))/sclfac);
    aTrack->Sety1(pos1.Y()/sclfac);
    aTrack->Seterr_y1(sqrt(cov1(1,1))/sclfac);
    aTrack->Setz1(pos1.Z()/sclfac);
    aTrack->Seterr_z1(sqrt(cov1(2,2))/sclfac);

    //fill final information
    aTrack->Setnhits(nhits);
//    aTrack->Setnhitsdch(nhitsdch);
    aTrack->SetnhitsBT(nhitsCSMBT);
    aTrack->SetnhitsTT(nhitsCSMTT);
    aTrack->Setchi2(fitStatus->getChi2());
    aTrack->Setdof(fitStatus->getNdf());
    aTrack->Setngoodhits(ngoodhits);
//    aTrack->Setngoodhitsdch(ngoodhitsdch);
    aTrack->SetngoodhitsBT(ngoodhitsCSMBT);
    aTrack->SetngoodhitsTT(ngoodhitsCSMTT);
    aTrack->SetIsFitted(fitstatus);

    if ( GetSP()->GetDoDisplay() ) {
        ftracks.push_back(new genfit::Track(fitTrack) );
    }
    delete fitter;

    return true;
}


//______________________________________________________________________________
Bool_t rAPPNUWSTTrackFit::Fit2TT(TObject *tmpTrack) {
    int fDebug=GetSP()->GetDebugLevel();//1;

    int trkid=0;
    TVector3 xyzhit0,momhit0;
    int nhits = 0;

    rAPPNUWSRecoTracksTT *aTrack = (rAPPNUWSRecoTracksTT *)tmpTrack;

    nhits = aTrack->Getnhits();
    if (nhits < 2) {
        printf(" ****  !!! Event not reconstructable: number of hits for TT signal track less than 2!\n");
        return false;
    }

    rAPPNUWSCSMTTHit *ahit0 = (rAPPNUWSCSMTTHit*) fBrHitsCSMTT->At(aTrack->GethitindexAt(0));
    xyzhit0=sclfac*TVector3(ahit0->GetfEntranceX(),ahit0->GetfEntranceY(),ahit0->GetfEntranceZ()); // mm -> cm
    momhit0=0.001*TVector3(ahit0->GetfEntranceMomX(),ahit0->GetfEntranceMomY(),ahit0->GetfEntranceMomZ()); // MeV -> GeV
    trkid=ahit0->GetfTrkIDofHit();


    //init values
    TVector3 xyz0=xyzhit0;//fVert;
    TVector3 pdir0=momhit0;
    pdir0.SetMag(1.);
    TVector3 pmom0=momhit0;//

    //Do initialization of initial covariance matrix with sigma_p,sigma_angle, 1cm position
    TMatrixDSym Cov(6); Cov.Zero();

    Cov[0][0] = Cov[1][1] =Cov[2][2] = sclfac*sclfac;//centimeters
    Cov[3][3] = Cov[4][4] =Cov[5][5] = 0.001*0.001;//GeV

    //-----------------------------------
    //init positron track with parameters from first State Vector and predefined Covariance matrix
    //-----------------------------------
    int pdgid=13;
    if(trkid<=fBrDataTrk->GetEntriesFast()&&trkid>0){
        for(int i=0;i<fBrDataTrk->GetEntriesFast();i++){
            rAPPNUWSGeantTrack* aMCTrack = ((rAPPNUWSGeantTrack*)fBrDataTrk->At(i));
            if(aMCTrack->GetfTrackID()==trkid){
                if (pdgid!=aMCTrack->GetfPDGCode()) {
                    pdgid=aMCTrack->GetfPDGCode();
                    if(fDebug) std::cout<<"Primary track n. "<<i<<" has different PDG "<<pdgid<<std::endl;
                    break;
                }
            }
        }
    }

    //
    if(fDebug)
        std::cout<<"set charge to pdgid ="<<pdgid<<std::endl;
    AbsTrackRep *rep = new RKTrackRep(pdgid);
    MeasuredStateOnPlane stateRef(rep);
    rep->setPosMomCov(stateRef,xyz0,pmom0,Cov);
    stateRef.setTime(0.);

    //init genfit track from initial state
    TVectorD seedState(6);
    TMatrixDSym seedCov(6);
    rep->get6DStateCov(stateRef, seedState, seedCov);
    Track fitTrack(rep,seedState, seedCov);
    fitTrack.setTimeSeed(0.);


    //-----------------------------------------------
    //fill hit information
    //-----------------------------------------------
    int nid=0;

//    //add vertex constrain
//    double sigmabeam=GetSP()->GetSigmaVtx();
//    if(sigmabeam>0){
//        TVectorD hitCoords(3);
//        TMatrixDSym hitCov(3);
//        for(int i=0;i<3;i++)
//            hitCoords(i)=gRandom->Gaus()*sigmabeam;
//        hitCov(0,0) = hitCov(1,1) = hitCov(2,2) = sigmabeam*sigmabeam;
//        genfit::SpacepointMeasurement* measurement = new genfit::SpacepointMeasurement(hitCoords, hitCov, 10, 100000, NULL);
//        fitTrack.insertMeasurement(measurement,nid++);
//        if(fDebug)
//            cout<<" add vertex constrain " <<hitCoords(0)<<" "<<hitCoords(1)<<" "<<hitCoords(2)<< " with +- "<<sigmabeam<<endl;
//    }

    int ihit0CSMTT=-1;
    int nhitsCSMTT=0;

    for(int ihit=0;ihit<nhits;ihit++){

//        rAPPNUWSRecoTracksTT *aTrack = (rAPPNUWSRecoTracksTT *)tmpTrack;
//        std::cout<<"Inserting hit i: "<<ihit<<" with n. "<<aTrack->GethitindexAt(ihit)<<std::endl;
        rAPPNUWSCSMTTHit *ahit =(rAPPNUWSCSMTTHit*) fBrHitsCSMTT->At(aTrack->GethitindexAt(ihit));
        addTThit (ahit, ihit, ihit0CSMTT, nhitsCSMTT, fitTrack, nid);

    }

    // ---- end of hit info filling ------------------------


    //  assert(fitTrack.checkConsistency());
    fitTrack.checkConsistency();
    genfit::FitStatus* fitStatus=fitTrack.getFitStatus(rep);
    if(fDebug){
        std::cout<<" init chi2 "<<fitStatus->getChi2()<<" nfailed "<<fitStatus->getNFailedPoints()
                     <<" P= "<<rep->getMomMag(stateRef)*rep->getCharge(stateRef)<<" +- "<<sqrt(rep->getMomVar(stateRef))
                     <<" nhits "<<nid<<" from "<<nhits/*<<" dch "<<nhitsdch*/<<" CSMTT "<<nhitsCSMTT<<std::endl;
        std::cout<<"init state ";xyz0.Print();std::cout<<" ";pmom0.Print();std::cout<<endl;
    }

    //choose different fitter
    genfit::AbsKalmanFitter* fitter = 0;
    switch(0/*GetSP()->GetKalmanType()*/){
    case 0:
        fitter=new DAF();
        break;
    case 1:
        fitter=new KalmanFitterRefTrack(20);
        break;
    case 2:
        fitter=new KalmanFitter(20);
        break;
    }
    /*
  if(GetSP()->GetKalmanType()>0){
    //use LR from patter recognition in case of usual KalmanFitter
    fitter->setMultipleMeasurementHandling(genfit::weightedClosestToPredictionWire);
  }*/

    if(fDebug>20){
        fitter->setDebugLvl(10);
        rep->setDebugLvl(10);
    }

    //-----------------------------------
    // FIT IT
    //-----------------------------------

    try{
        fitter->processTrack(&fitTrack);
    }catch(Exception& e){
        if(fDebug) std::cout<<"on fitting "<<e.what()<<std::endl;
    }
    fitStatus=fitTrack.getFitStatus(rep);
    bool fitstatus=fitStatus->isFitConverged()&&(fitStatus->getNFailedPoints()==0);
    if(fDebug) fitStatus->Print();


    TVector3 pos,mom;
    TMatrixDSym cov(6);
    TVector3 pos1,mom1;
    TMatrixDSym cov1(6);
    TVector3 pos2,mom2;
    TMatrixDSym cov2(6);
    double pmom=0;
    double tof=0;
    double sigmap=0.;

    //-----------------------------------
    // fill info from first hit
    //-----------------------------------

    try{
        const MeasuredStateOnPlane& stFirst=fitTrack.getFittedState();
        pmom=rep->getMomMag(stFirst)*rep->getCharge(stFirst);
        stFirst.getPosMomCov(pos,mom,cov);
        tof=stFirst.getTime();
    }catch(Exception& e){
        if(fDebug) std::cout<<"on getting state "<<e.what()<<std::endl;
    }


    if(fDebug)
        std::cout<<" chi2 "<<fitStatus->getChi2()<<" nfailed "<<fitStatus->getNFailedPoints()
        <<" P= "<<pmom<<" fitok="<<fitstatus<<std::endl;

    if(fDebug){std::cout<<"fitted xyz ";pos.Print();std::cout<<" mom ";mom.Print();std::cout<<endl;}

    //-----------------------------------
    //set states on hits
    //-----------------------------------

    unsigned int numhits = fitTrack.getNumPoints();

    int ngoodhits=0;
//    double sumddist=0;

    aTrack->SetStateVectorSize(nhits);
    aTrack->GetSkipped().resize(nhits,true);

    if(fitstatus){
        try{

            for(unsigned int jhit=0;jhit<numhits;jhit++){
                TrackPoint* point = fitTrack.getPoint(jhit);
                int ihit=point->getRawMeasurement(0)->getHitId();
                int idetid=point->getRawMeasurement(0)->getDetId();
                //skip virtual hit
                //        if(ihit>=1000) continue;

                //skip point without fitted information
                if(!point->hasFitterInfo(rep)) continue;

                KalmanFitterInfo* fi = static_cast<KalmanFitterInfo*>(point->getFitterInfo(rep));
                //get weights for LR combinations
                std::vector<double> dafWeights = fi->getWeights();

                //maximum weigth in fitting (from LR positions)
                int imaxdaf=std::distance(dafWeights.begin(),
                        std::max_element(dafWeights.begin(),dafWeights.end()));
                double maxdaf=dafWeights[imaxdaf];


                //fill histogram with final chi2 per hit
                const MeasurementOnPlane& residual = fi->getResidual(imaxdaf, false, false);
                const TVectorD& resid(residual.getState());

                //dont fill StateVector forr skipped hits during fitting(in normal case hit must have weight=1.)
                if(maxdaf<0.5) {
                    if(fDebug>9) std::cout<<"skip point "<<endl;
                    continue;
                }

                //fill biased best StateVector on hit
                // (averaged from forward-backward propagation)
                const MeasuredStateOnPlane& state=fi->getFittedState(true);
                state.getPosMomCov(pos,mom,cov);

//                //unbiased
//                const MeasuredStateOnPlane& state2=fi->getFittedState(false);
//                state2.getPosMomCov(pos2,mom2,cov2);

                /*if(idetid==0){
                    //average T0 shift over hits
                    sumddist+=resid(0)*(imaxdaf?1:-1);
                    ngoodhitsdch++;
                }else*/

                if(idetid<10){ //CSMTT or CSMBT hit
                    aTrack->SetSkippedAt(ihit,false);
                    *aTrack->GetStateVectorAt(ihit)=pos;
                    ngoodhits++;
                    if(IsHXresActive()) {
                        GetHXres()->Fill(resid(0));
                    }
                    if(IsHYresActive()) {
                        GetHYres()->Fill(resid(1));
                    }
//                    if(IsHZresActive()) {
//                        GetHYres()->Fill(resid(2));
//                    }
//                    rAPPNUWSCSMTTHit *ahit = (rAPPNUWSCSMTTHit*) fBrHitsCSMTT->At(aTrack->GethitindexAt(ihit));
                    if(fDebug>9) {
                        cout<<idetid<<" "<<ihit<<" track aver "<<state.getState()(3)<<" "<<state.getState()(4)<<" exact mes 0 0 dy,dz not biased "<<resid(0)<<" "<<resid(1)
                        <<" trk xyz ";pos.Print();std::cout<<" mom "<<mom.Y()<<endl;
                    }
                }
                // state.Print();
                // cov.Print();
                // state2.Print();
                // cov2.Print();
                if(ihit==aTrack->GethitindexAt(0))
                    if(IsHMomentumActive()) GetHMomentum()->Fill(pmom0.Mag(),mom.Mag()/pmom0.Mag()-1);
                if(fDebug>9) {
                    std::cout<<jhit<<" idetid "<<idetid<<" id "<<ihit<<" at hit ";pos.Print();std::cout<<" ";mom.Print();std::cout<<endl;
                }
            }
        }catch(Exception& e){
            if(fDebug) std::cout<<"on getting points "<<e.what()<<std::endl;
            fitstatus=false;
        }
//        sumddist/=ngoodhitsdch;
        if(fDebug) std::cout<<" filtrated hits "<<numhits-ngoodhits/*<<" average ddist "<<sumddist/(0.4/150e-9)*/<<std::endl;
    }


    //-----------------------------------
    //propagate to
    //-----------------------------------
    if(fitstatus){

        //force backward propagation(will be working forr only finite plane
        rep->setPropDir(-1);
        //take first fitted point
        TrackPoint* tp = fitTrack.getPointWithFitterInfo(0);
        if (tp == NULL) {std::cout << "Track has no TrackPoint with fitterInfo!(but fitstatus ok?)"<<std::endl;}
        KalmanFitterInfo* fi = static_cast<KalmanFitterInfo*>(tp->getFitterInfo(rep));
        MeasuredStateOnPlane state;

        //extrapolate to Upper face of the Top Tracker
        bool isUp=true;
        try{
            state=fi->getFittedState(true);
            rep->extrapolateToLine(state,TVector3(0,fGeometry->GetCSMTtracker()->distOut()*sclfac,0),TVector3(0,0,1));
        }catch(Exception& e){
            if(fDebug) std::cout<<"on extrapolation to center line "<<e.what()<<std::endl;
            isUp=false;
        }
//        double tof_target=1e9;
        if(isUp){
//            tof_target=state.getTime();
            state.getPosMomCov(pos,mom,cov);
            double momrec=mom.Mag();
            sigmap=momrec*momrec*TMath::Sqrt(state.getCov()(0,0));

        }
        if(fDebug) {
            std::cout<<"vertex chi2 "<<fitStatus->getChi2()<<" ndf "<<fitStatus->getNdf()
            <<" nhits "<<nhits/*<<" dch "<<nhitsdch*/<<" CSMTT "<<nhitsCSMTT<<" nfailed "<<fitStatus->getNFailedPoints()
            <<" P= "<<mom.Mag()*rep->getCharge(state)<<" +- "<<sigmap<<" fitok="<<fitstatus
            <<" pos "; pos.Print();
            std::cout<<" mom "; mom.Print();
            //std::cout<<std::endl;
        }

        //extrapolate to Bottom face of the Top Tracker
        rep->setPropDir(1);
        bool isBt=true;
        try{
            state=fi->getFittedState(true);
            rep->extrapolateToLine(state,TVector3(0,fGeometry->GetCSMTtracker()->distIn()*sclfac,0),TVector3(0,0,1));
        }catch(Exception& e){
            if(fDebug) std::cout<<"on extrapolation to center line "<<e.what()<<std::endl;
            isBt=false;
        }
//        double tof_target=1e9;
        if(isBt){
//            tof_target=state.getTime();
            state.getPosMomCov(pos1,mom1,cov1);
        }

        //extrapolate to Upper face of the Bottom Tracker
        rep->setPropDir(1);
        bool isBT=true;
        try{
            state=fi->getFittedState(true);
            rep->extrapolateToLine(state,TVector3(0,fGeometry->GetCSMBtracker()->distOut()*sclfac,0),TVector3(0,0,1));
        }catch(Exception& e){
            if(fDebug) std::cout<<"on extrapolation to center line "<<e.what()<<std::endl;
            isBT=false;
        }
//        double tof_target=1e9;
        if(isBT){
//            tof_target=state.getTime();
            state.getPosMomCov(pos2,mom2,cov2);
        }

    }

    aTrack->Setx0(pos.X()/sclfac);
    aTrack->Seterr_x0(sqrt(cov(0,0))/sclfac);
    aTrack->Sety0(pos.Y()/sclfac);
    aTrack->Seterr_y0(sqrt(cov(1,1))/sclfac);
    aTrack->Setz0(pos.Z()/sclfac);
    aTrack->Seterr_z0(sqrt(cov(2,2))/sclfac);
    aTrack->Settheta(mom.Theta());
    aTrack->Seterr_theta(0.);
    aTrack->Setphi(mom.Phi());
    aTrack->Seterr_phi(0.);
    aTrack->SetMomentum(mom.Mag());
    aTrack->SetErr_Momentum(sigmap);
    aTrack->Setmom(mom);
    aTrack->Getcov()->ResizeTo(6,6);
    aTrack->Setcov(cov);

    aTrack->Setx1(pos1.X()/sclfac);
    aTrack->Seterr_x1(sqrt(cov1(0,0))/sclfac);
    aTrack->Sety1(pos1.Y()/sclfac);
    aTrack->Seterr_y1(sqrt(cov1(1,1))/sclfac);
    aTrack->Setz1(pos1.Z()/sclfac);
    aTrack->Seterr_z1(sqrt(cov1(2,2))/sclfac);

    aTrack->Setx2(pos2.X()/sclfac);
    aTrack->Seterr_x2(sqrt(cov2(0,0))/sclfac);
    aTrack->Sety2(pos2.Y()/sclfac);
    aTrack->Seterr_y2(sqrt(cov2(1,1))/sclfac);
    aTrack->Setz2(pos2.Z()/sclfac);
    aTrack->Seterr_z2(sqrt(cov2(2,2))/sclfac);

    //fill final information
    aTrack->Setnhits(nhits);//nhitsCSMTT
    aTrack->Setngoodhits(ngoodhits);
    aTrack->Setchi2(fitStatus->getChi2());
    aTrack->Setdof(fitStatus->getNdf());
    aTrack->SetIsFitted(fitstatus);

    if ( GetSP()->GetDoDisplay() ) {
        ftracks.push_back(new genfit::Track(fitTrack) );
    }
    delete fitter;

    return true;
}

//______________________________________________________________________________
Bool_t rAPPNUWSTTrackFit::Fit2BT(TObject *tmpTrack) {
    int fDebug=GetSP()->GetDebugLevel();//1;

    int trkid=0;
    TVector3 xyzhit0,momhit0;
    int nhits = 0;

    rAPPNUWSRecoTracksBT *aTrack = (rAPPNUWSRecoTracksBT *)tmpTrack;

    nhits = aTrack->Getnhits();
    if (nhits < 2) {
        printf(" ****  !!! Event not reconstructable: number of hits for BT signal track less than 2!\n");
        return false;
    }

    rAPPNUWSCSMBTHit *ahit0 = (rAPPNUWSCSMBTHit*) fBrHitsCSMBT->At(aTrack->GethitindexAt(0));
    xyzhit0=sclfac*TVector3(ahit0->GetfEntranceX(),ahit0->GetfEntranceY(),ahit0->GetfEntranceZ()); // mm -> cm
    momhit0=0.001*TVector3(ahit0->GetfEntranceMomX(),ahit0->GetfEntranceMomY(),ahit0->GetfEntranceMomZ()); // MeV -> GeV
    trkid=ahit0->GetfTrkIDofHit();


    //init values
    TVector3 xyz0=xyzhit0;//fVert;
    TVector3 pdir0=momhit0;
    pdir0.SetMag(1.);
    TVector3 pmom0=momhit0;//

    //Do initialization of initial covariance matrix with sigma_p,sigma_angle, 1cm position
    TMatrixDSym Cov(6); Cov.Zero();

    Cov[0][0] = Cov[1][1] =Cov[2][2] = sclfac*sclfac;//centimeters
    Cov[3][3] = Cov[4][4] =Cov[5][5] = 0.001*0.001;//GeV

    //-----------------------------------
    //init positron track with parameters from first State Vector and predefined Covariance matrix
    //-----------------------------------
    int pdgid=13;
    if(trkid<=fBrDataTrk->GetEntriesFast()&&trkid>0){
        for(int i=0;i<fBrDataTrk->GetEntriesFast();i++){
            rAPPNUWSGeantTrack* aMCTrack = ((rAPPNUWSGeantTrack*)fBrDataTrk->At(i));
            if(aMCTrack->GetfTrackID()==trkid){
                if (pdgid!=aMCTrack->GetfPDGCode()) {
                    pdgid=aMCTrack->GetfPDGCode();
                    if(fDebug) std::cout<<"Primary track n. "<<i<<" has different PDG "<<pdgid<<std::endl;
                    break;
                }
            }
        }
    }

    //
    if(fDebug)
        std::cout<<"set charge to pdgid ="<<pdgid<<std::endl;
    AbsTrackRep *rep = new RKTrackRep(pdgid);
    MeasuredStateOnPlane stateRef(rep);
    rep->setPosMomCov(stateRef,xyz0,pmom0,Cov);
    stateRef.setTime(0.);

    //init genfit track from initial state
    TVectorD seedState(6);
    TMatrixDSym seedCov(6);
    rep->get6DStateCov(stateRef, seedState, seedCov);
    Track fitTrack(rep,seedState, seedCov);
    fitTrack.setTimeSeed(0.);


    //-----------------------------------------------
    //fill hit information
    //-----------------------------------------------
    int nid=0;

//    //add vertex constrain
//    double sigmabeam=GetSP()->GetSigmaVtx();
//    if(sigmabeam>0){
//        TVectorD hitCoords(3);
//        TMatrixDSym hitCov(3);
//        for(int i=0;i<3;i++)
//            hitCoords(i)=gRandom->Gaus()*sigmabeam;
//        hitCov(0,0) = hitCov(1,1) = hitCov(2,2) = sigmabeam*sigmabeam;
//        genfit::SpacepointMeasurement* measurement = new genfit::SpacepointMeasurement(hitCoords, hitCov, 10, 100000, NULL);
//        fitTrack.insertMeasurement(measurement,nid++);
//        if(fDebug)
//            cout<<" add vertex constrain " <<hitCoords(0)<<" "<<hitCoords(1)<<" "<<hitCoords(2)<< " with +- "<<sigmabeam<<endl;
//    }

    int ihit0CSMBT=-1;
    int nhitsCSMBT=0;

    for(int ihit=0;ihit<nhits;ihit++){

//        rAPPNUWSRecoTracksBT *aTrack = (rAPPNUWSRecoTracksBT *)tmpTrack;
//        std::cout<<"Inserting hit i: "<<ihit<<" with n. "<<aTrack->GethitindexAt(ihit)<<std::endl;
        rAPPNUWSCSMBTHit *ahit =(rAPPNUWSCSMBTHit*) fBrHitsCSMBT->At(aTrack->GethitindexAt(ihit));
        addBThit (ahit, ihit, ihit0CSMBT, nhitsCSMBT, fitTrack, nid);

    }

    // ---- end of hit info filling ------------------------


    //  assert(fitTrack.checkConsistency());
    fitTrack.checkConsistency();
    genfit::FitStatus* fitStatus=fitTrack.getFitStatus(rep);
    if(fDebug){
        std::cout<<" init chi2 "<<fitStatus->getChi2()<<" nfailed "<<fitStatus->getNFailedPoints()
                     <<" P= "<<rep->getMomMag(stateRef)*rep->getCharge(stateRef)<<" +- "<<sqrt(rep->getMomVar(stateRef))
                     <<" nhits "<<nid<<" from "<<nhits/*<<" dch "<<nhitsdch*/<<" CSMBT "<<nhitsCSMBT<<std::endl;
        std::cout<<"init state ";xyz0.Print();std::cout<<" ";pmom0.Print();std::cout<<endl;
    }

    //choose different fitter
    genfit::AbsKalmanFitter* fitter = 0;
    switch(0/*GetSP()->GetKalmanType()*/){
    case 0:
        fitter=new DAF();
        break;
    case 1:
        fitter=new KalmanFitterRefTrack(20);
        break;
    case 2:
        fitter=new KalmanFitter(20);
        break;
    }
    /*
  if(GetSP()->GetKalmanType()>0){
    //use LR from patter recognition in case of usual KalmanFitter
    fitter->setMultipleMeasurementHandling(genfit::weightedClosestToPredictionWire);
  }*/

    if(fDebug>20){
        fitter->setDebugLvl(10);
        rep->setDebugLvl(10);
    }

    //-----------------------------------
    // FIT IT
    //-----------------------------------

    try{
        fitter->processTrack(&fitTrack);
    }catch(Exception& e){
        if(fDebug) std::cout<<"on fitting "<<e.what()<<std::endl;
    }
    fitStatus=fitTrack.getFitStatus(rep);
    bool fitstatus=fitStatus->isFitConverged()&&(fitStatus->getNFailedPoints()==0);
    if(fDebug) fitStatus->Print();


    TVector3 pos,mom;
    TMatrixDSym cov(6);
    TVector3 pos1,mom1;
    TMatrixDSym cov1(6);
    TVector3 pos2,mom2;
    TMatrixDSym cov2(6);
    double pmom=0;
    double tof=0;
    double sigmap=0.;

    //-----------------------------------
    // fill info from first hit
    //-----------------------------------

    try{
        const MeasuredStateOnPlane& stFirst=fitTrack.getFittedState();
        pmom=rep->getMomMag(stFirst)*rep->getCharge(stFirst);
        stFirst.getPosMomCov(pos,mom,cov);
        tof=stFirst.getTime();
    }catch(Exception& e){
        if(fDebug) std::cout<<"on getting state "<<e.what()<<std::endl;
    }


    if(fDebug)
        std::cout<<" chi2 "<<fitStatus->getChi2()<<" nfailed "<<fitStatus->getNFailedPoints()
        <<" P= "<<pmom<<" fitok="<<fitstatus<<std::endl;

    if(fDebug){std::cout<<"fitted xyz ";pos.Print();std::cout<<" mom ";mom.Print();std::cout<<endl;}

    //-----------------------------------
    //set states on hits
    //-----------------------------------

    unsigned int numhits = fitTrack.getNumPoints();

    int ngoodhits=0;
//    double sumddist=0;

    aTrack->SetStateVectorSize(nhits);
    aTrack->GetSkipped().resize(nhits,true);

    if(fitstatus){
        try{

            for(unsigned int jhit=0;jhit<numhits;jhit++){
                TrackPoint* point = fitTrack.getPoint(jhit);
                int ihit=point->getRawMeasurement(0)->getHitId();
                int idetid=point->getRawMeasurement(0)->getDetId();
                //skip virtual hit
                //        if(ihit>=1000) continue;

                //skip point without fitted information
                if(!point->hasFitterInfo(rep)) continue;

                KalmanFitterInfo* fi = static_cast<KalmanFitterInfo*>(point->getFitterInfo(rep));
                //get weights for LR combinations
                std::vector<double> dafWeights = fi->getWeights();

                //maximum weigth in fitting (from LR positions)
                int imaxdaf=std::distance(dafWeights.begin(),
                        std::max_element(dafWeights.begin(),dafWeights.end()));
                double maxdaf=dafWeights[imaxdaf];


                //fill histogram with final chi2 per hit
                const MeasurementOnPlane& residual = fi->getResidual(imaxdaf, false, false);
                const TVectorD& resid(residual.getState());

                //dont fill StateVector forr skipped hits during fitting(in normal case hit must have weight=1.)
                if(maxdaf<0.5) {
                    if(fDebug>9) std::cout<<"skip point "<<endl;
                    continue;
                }

                //fill biased best StateVector on hit
                // (averaged from forward-backward propagation)
                const MeasuredStateOnPlane& state=fi->getFittedState(true);
                state.getPosMomCov(pos,mom,cov);

//                //unbiased
//                const MeasuredStateOnPlane& state2=fi->getFittedState(false);
//                state2.getPosMomCov(pos2,mom2,cov2);

                /*if(idetid==0){
                    //average T0 shift over hits
                    sumddist+=resid(0)*(imaxdaf?1:-1);
                    ngoodhitsdch++;
                }else*/

                if(idetid<10){ //CSMTT or CSMBT hit
                    aTrack->SetSkippedAt(ihit,false);
                    *aTrack->GetStateVectorAt(ihit)=pos;
                    ngoodhits++;
                    if(IsHXresActive()) {
                        GetHXres()->Fill(resid(0));
                    }
                    if(IsHYresActive()) {
                        GetHYres()->Fill(resid(1));
                    }
//                    if(IsHZresActive()) {
//                        GetHYres()->Fill(resid(2));
//                    }
//                    rAPPNUWSCSMBTHit *ahit = (rAPPNUWSCSMBTHit*) fBrHitsCSMBT->At(aTrack->GethitindexAt(ihit));
                    if(fDebug>9) {
                        cout<<idetid<<" "<<ihit<<" track aver "<<state.getState()(3)<<" "<<state.getState()(4)<<" exact mes 0 0 dy,dz not biased "<<resid(0)<<" "<<resid(1)
                        <<" trk xyz ";pos.Print();std::cout<<" mom "<<mom.Y()<<endl;
                    }
                }
                // state.Print();
                // cov.Print();
                // state2.Print();
                // cov2.Print();
                if(ihit==aTrack->GethitindexAt(0))
                    if(IsHMomentumActive()) GetHMomentum()->Fill(pmom0.Mag(),mom.Mag()/pmom0.Mag()-1);
                if(fDebug>9) {
                    std::cout<<jhit<<" idetid "<<idetid<<" id "<<ihit<<" at hit ";pos.Print();std::cout<<" ";mom.Print();std::cout<<endl;
                }
            }
        }catch(Exception& e){
            if(fDebug) std::cout<<"on getting points "<<e.what()<<std::endl;
            fitstatus=false;
        }
//        sumddist/=ngoodhitsdch;
        if(fDebug) std::cout<<" filtrated hits "<<numhits-ngoodhits/*<<" average ddist "<<sumddist/(0.4/150e-9)*/<<std::endl;
    }


    //-----------------------------------
    //propagate to
    //-----------------------------------
    if(fitstatus){

        //force backward propagation(will be working forr only finite plane
        rep->setPropDir(-1);
        //take first fitted point
        TrackPoint* tp = fitTrack.getPointWithFitterInfo(0);
        if (tp == NULL) {std::cout << "Track has no TrackPoint with fitterInfo!(but fitstatus ok?)"<<std::endl;}
        KalmanFitterInfo* fi = static_cast<KalmanFitterInfo*>(tp->getFitterInfo(rep));
        MeasuredStateOnPlane state;

        //extrapolate to Upper face of the Top Tracker
        bool isUp=true;
        try{
            state=fi->getFittedState(true);
            rep->extrapolateToLine(state,TVector3(0,fGeometry->GetCSMBtracker()->distOut()*sclfac,0),TVector3(0,0,1));
        }catch(Exception& e){
            if(fDebug) std::cout<<"on extrapolation to center line "<<e.what()<<std::endl;
            isUp=false;
        }
//        double tof_target=1e9;
        if(isUp){
//            tof_target=state.getTime();
            state.getPosMomCov(pos,mom,cov);
            double momrec=mom.Mag();
            sigmap=momrec*momrec*TMath::Sqrt(state.getCov()(0,0));

        }
        if(fDebug) {
            std::cout<<"vertex chi2 "<<fitStatus->getChi2()<<" ndf "<<fitStatus->getNdf()
            <<" nhits "<<nhits/*<<" dch "<<nhitsdch*/<<" CSMBT "<<nhitsCSMBT<<" nfailed "<<fitStatus->getNFailedPoints()
            <<" P= "<<mom.Mag()*rep->getCharge(state)<<" +- "<<sigmap<<" fitok="<<fitstatus
            <<" pos "; pos.Print();
            std::cout<<" mom "; mom.Print();
            //std::cout<<std::endl;
        }

        //extrapolate to Bottom face of the Top Tracker
        rep->setPropDir(1);
        bool isBt=true;
        try{
            state=fi->getFittedState(true);
            rep->extrapolateToLine(state,TVector3(0,fGeometry->GetCSMBtracker()->distIn()*sclfac,0),TVector3(0,0,1));
        }catch(Exception& e){
            if(fDebug) std::cout<<"on extrapolation to center line "<<e.what()<<std::endl;
            isBt=false;
        }
//        double tof_target=1e9;
        if(isBt){
//            tof_target=state.getTime();
            state.getPosMomCov(pos1,mom1,cov1);
        }

        //extrapolate to Bottom face of the Upper Tracker
        rep->setPropDir(-1);
        bool isTT=true;
        try{
            state=fi->getFittedState(true);
            rep->extrapolateToLine(state,TVector3(0,fGeometry->GetCSMTtracker()->distIn()*sclfac,0),TVector3(0,0,1));
        }catch(Exception& e){
            if(fDebug) std::cout<<"on extrapolation to center line "<<e.what()<<std::endl;
            isTT=false;
        }
//        double tof_target=1e9;
        if(isTT){
//            tof_target=state.getTime();
            state.getPosMomCov(pos2,mom2,cov2);
        }

    }

    aTrack->Setx0(pos.X()/sclfac);
    aTrack->Seterr_x0(sqrt(cov(0,0))/sclfac);
    aTrack->Sety0(pos.Y()/sclfac);
    aTrack->Seterr_y0(sqrt(cov(1,1))/sclfac);
    aTrack->Setz0(pos.Z()/sclfac);
    aTrack->Seterr_z0(sqrt(cov(2,2))/sclfac);
    aTrack->Settheta(mom.Theta());
    aTrack->Seterr_theta(0.);
    aTrack->Setphi(mom.Phi());
    aTrack->Seterr_phi(0.);
    aTrack->SetMomentum(mom.Mag());
    aTrack->SetErr_Momentum(sigmap);
    aTrack->Setmom(mom);
    aTrack->Getcov()->ResizeTo(6,6);
    aTrack->Setcov(cov);

    aTrack->Setx1(pos1.X()/sclfac);
    aTrack->Seterr_x1(sqrt(cov1(0,0))/sclfac);
    aTrack->Sety1(pos1.Y()/sclfac);
    aTrack->Seterr_y1(sqrt(cov1(1,1))/sclfac);
    aTrack->Setz1(pos1.Z()/sclfac);
    aTrack->Seterr_z1(sqrt(cov1(2,2))/sclfac);

    aTrack->Setx2(pos2.X()/sclfac);
    aTrack->Seterr_x2(sqrt(cov2(0,0))/sclfac);
    aTrack->Sety2(pos2.Y()/sclfac);
    aTrack->Seterr_y2(sqrt(cov2(1,1))/sclfac);
    aTrack->Setz2(pos2.Z()/sclfac);
    aTrack->Seterr_z2(sqrt(cov2(2,2))/sclfac);

    //fill final information
    aTrack->Setnhits(nhits);//nhitsCSMBT
    aTrack->Setngoodhits(ngoodhits);
    aTrack->Setchi2(fitStatus->getChi2());
    aTrack->Setdof(fitStatus->getNdf());
    aTrack->SetIsFitted(fitstatus);

    if ( GetSP()->GetDoDisplay() ) {
        ftracks.push_back(new genfit::Track(fitTrack));
    }

    delete fitter;

    return true;
}

//______________________________________________________________________________
void rAPPNUWSTTrackFit::addTThit (rAPPNUWSCSMTTHit *ahit, int &ihit, int &ihit0, int &nhits, Track &fitTrack, int &nid) {
    int fDebug=GetSP()->GetDebugLevel();//1;

//    rAPPNUWSRecoTracksTT *aTrack = (rAPPNUWSRecoTracksTT *)tmpTrack;

    if(ihit0<0) ihit0=0;
    nhits++;
//    rAPPNUWSCSMTTHit *ahit =(rAPPNUWSCSMTTHit*) fBrHitsCSMTT->At(aTrack->GethitindexAt(ihit));

    unsigned long nRO = ahit->GetfChanId();
    fGeometry->GetCSMTTROChanHandle()->SelectRODet(nRO);
    bool isFw = fGeometry->GetCSMTTROChanHandle()->isFwLayer();

    double pxlResolution=round(fGeometry->GetCSMTTROChanHandle()->GetROChanFstSdPitch()*2886.751345948)*1e-4*sclfac;  //1e+4*1/sqrt(12)=2886.751345948 (1e+4 to round at the um level), 1e-4*0.1 for mm -> cm
    double pxlResolutionSndSd=round(fGeometry->GetCSMTTROChanHandle()->GetROChanSndSdPitch()*2886.751345948)*1e-4*sclfac;
    TMatrixDSym hitpxlCov(2);
    hitpxlCov.UnitMatrix();
    hitpxlCov *= pxlResolution*pxlResolutionSndSd;

    const CLHEP::Hep3Vector& lclmid   = fGeometry->GetCSMTTROChanHandle()->GetROChanCenterLcl();

    TVectorD hitCoords(2);
    hitCoords[0] = sclfac*lclmid.x();
    hitCoords[1] = sclfac*lclmid.z();
    genfit::PlanarMeasurement* measurement = new genfit::PlanarMeasurement(hitCoords, hitpxlCov, 0, ihit, nullptr);

    const CLHEP::Hep3Vector& ldmid   = fGeometry->GetCSMTTROChanHandle()->GetROLayerMidPoint();
    const CLHEP::Hep3Vector& ldFstSdDir   = fGeometry->GetCSMTTROChanHandle()->GetLadderFstSdDir();
    const CLHEP::Hep3Vector& ldSndSdDir   = fGeometry->GetCSMTTROChanHandle()->GetLadderSndSdDir();
    TVector3 ldMid(sclfac*ldmid.x(),sclfac*ldmid.y(),sclfac*ldmid.z());
    TVector3 udir(ldFstSdDir.x(),ldFstSdDir.y(),ldFstSdDir.z());
    TVector3 vdir(ldSndSdDir.x(),ldSndSdDir.y(),ldSndSdDir.z());

    measurement->setPlane(genfit::SharedPlanePtr(new genfit::DetPlane(ldMid, udir, vdir)), 0);//++nid);
    fitTrack.insertMeasurement(measurement);//,++nid);
    if(fDebug>1) {
        const CLHEP::Hep3Vector& glbmid = fGeometry->GetCSMTTROChanHandle()->GetROChanCenterGbl();
        TVector3 pixel(sclfac*glbmid.x(),sclfac*glbmid.y(),sclfac*glbmid.z());
        TVector3 hitPnt(sclfac*ahit->GetfEntranceX(),sclfac*ahit->GetfEntranceY(),sclfac*ahit->GetfEntranceZ());
        TVector3 pixelM(ldMid.x()+hitCoords[0]*udir.x()+hitCoords[1]*vdir.x(),
                ldMid.y()+hitCoords[0]*udir.y()+hitCoords[1]*vdir.y(),
                ldMid.z()+hitCoords[0]*udir.z()+hitCoords[1]*vdir.z());
        cout<<std::endl<<" add "<<ihit<<" CSMTT mes in Sec "<< fGeometry->GetCSMTTROChanHandle()->GetPhiSecId()
                                      <<" nRO "<< nRO
                                      <<" lay "<< fGeometry->GetCSMTTROChanHandle()->GetLayerId()
                                      <<" lad "<< fGeometry->GetCSMTTROChanHandle()->GetLadderId()
                                      <<" is Fw "<<isFw
                                      <<" pos: "<<hitCoords[0]<<" "<<hitCoords[1]<<endl;
        cout<<" xyz "<<hitPnt.X()<<" "<<hitPnt.Y()<<" "<<hitPnt.Z()<< " with +- "<<pxlResolution<< " with +- "<<pxlResolutionSndSd<<" T "<<ahit->GetfGlobalTime()<<endl;

        cout<<"  M  "<<pixelM.X()<<" "<<pixelM.Y()<<" "<<pixelM.Z()<<" dist on Plane "<<sqrt(pow((pixelM-hitPnt).Dot(udir),2)+pow((pixelM-hitPnt).Dot(vdir),2))<<" dist "<<(pixelM-hitPnt).Mag()<<endl;
        cout<<"  P  "<<pixel.X()<<" "<<pixel.Y()<<" "<<pixel.Z()<<" dist on Plane "<<sqrt(pow((pixel-hitPnt).Dot(udir),2)+pow((pixel-hitPnt).Dot(vdir),2))<<" dist "<<(pixel-hitPnt).Mag()<<endl;

        cout<<"Ld mid: "; ldMid.Print();
        cout<<"U dir: "; udir.Print();
        cout<<"V dir: "; vdir.Print();
        cout<<std::endl;
    }

}

//______________________________________________________________________________
void rAPPNUWSTTrackFit::addBThit (rAPPNUWSCSMBTHit *ahit, int &ihit, int &ihit0, int &nhits, Track &fitTrack, int &nid) {
    int fDebug=GetSP()->GetDebugLevel();//1;

//    rAPPNUWSRecoTracksBT *aTrack = (rAPPNUWSRecoTracksBT *)tmpTrack;

    if(ihit0<0) ihit0=0;
    nhits++;
//    rAPPNUWSCSMBTHit *ahit =(rAPPNUWSCSMBTHit*) fBrHitsCSMBT->At(aTrack->GethitindexAt(ihit));

    unsigned long nRO = ahit->GetfChanId();
    fGeometry->GetCSMBTROChanHandle()->SelectRODet(nRO);
    bool isFw = fGeometry->GetCSMBTROChanHandle()->isFwLayer();

    double pxlResolution=round(fGeometry->GetCSMBTROChanHandle()->GetROChanFstSdPitch()*2886.751345948)*1e-4*sclfac;  //1e+4*1/sqrt(12)=2886.751345948 (1e+4 to round at the um level), 1e-4*0.1 for mm -> cm
    double pxlResolutionSndSd=round(fGeometry->GetCSMBTROChanHandle()->GetROChanSndSdPitch()*2886.751345948)*1e-4*sclfac;
    TMatrixDSym hitpxlCov(2);
    hitpxlCov.UnitMatrix();
    hitpxlCov *= pxlResolution*pxlResolutionSndSd;

    const CLHEP::Hep3Vector& lclmid   = fGeometry->GetCSMBTROChanHandle()->GetROChanCenterLcl();

    TVectorD hitCoords(2);
    hitCoords[0] = sclfac*lclmid.x();
    hitCoords[1] = sclfac*lclmid.z();
    genfit::PlanarMeasurement* measurement = new genfit::PlanarMeasurement(hitCoords, hitpxlCov, 1, ihit, nullptr);

    const CLHEP::Hep3Vector& ldmid   = fGeometry->GetCSMBTROChanHandle()->GetROLayerMidPoint();
    const CLHEP::Hep3Vector& ldFstSdDir   = fGeometry->GetCSMBTROChanHandle()->GetLadderFstSdDir();
    const CLHEP::Hep3Vector& ldSndSdDir   = fGeometry->GetCSMBTROChanHandle()->GetLadderSndSdDir();
    TVector3 ldMid(sclfac*ldmid.x(),sclfac*ldmid.y(),sclfac*ldmid.z());
    TVector3 udir(ldFstSdDir.x(),ldFstSdDir.y(),ldFstSdDir.z());
    TVector3 vdir(ldSndSdDir.x(),ldSndSdDir.y(),ldSndSdDir.z());

    measurement->setPlane(genfit::SharedPlanePtr(new genfit::DetPlane(ldMid, udir, vdir)), 0);//++nid);
    fitTrack.insertMeasurement(measurement);//,++nid);
    if(fDebug>1) {
        const CLHEP::Hep3Vector& glbmid = fGeometry->GetCSMBTROChanHandle()->GetROChanCenterGbl();
        TVector3 pixel(sclfac*glbmid.x(),sclfac*glbmid.y(),sclfac*glbmid.z());
        TVector3 hitPnt(sclfac*ahit->GetfEntranceX(),sclfac*ahit->GetfEntranceY(),sclfac*ahit->GetfEntranceZ());
        TVector3 pixelM(ldMid.x()+hitCoords[0]*udir.x()+hitCoords[1]*vdir.x(),
                ldMid.y()+hitCoords[0]*udir.y()+hitCoords[1]*vdir.y(),
                ldMid.z()+hitCoords[0]*udir.z()+hitCoords[1]*vdir.z());
        cout<<std::endl<<" add "<<ihit<<" CSMBT mes in Sec "<< fGeometry->GetCSMBTROChanHandle()->GetPhiSecId()
                                      <<" nRO "<< nRO
                                      <<" lay "<< fGeometry->GetCSMBTROChanHandle()->GetLayerId()
                                      <<" lad "<< fGeometry->GetCSMBTROChanHandle()->GetLadderId()
                                      <<" is Fw "<<isFw
                                      <<" pos: "<<hitCoords[0]<<" "<<hitCoords[1]<<endl;
        cout<<" xyz "<<hitPnt.X()<<" "<<hitPnt.Y()<<" "<<hitPnt.Z()<< " with +- "<<pxlResolution<< " with +- "<<pxlResolutionSndSd<<" T "<<ahit->GetfGlobalTime()<<endl;

        cout<<"  M  "<<pixelM.X()<<" "<<pixelM.Y()<<" "<<pixelM.Z()<<" dist on Plane "<<sqrt(pow((pixelM-hitPnt).Dot(udir),2)+pow((pixelM-hitPnt).Dot(vdir),2))<<" dist "<<(pixelM-hitPnt).Mag()<<endl;
        cout<<"  P  "<<pixel.X()<<" "<<pixel.Y()<<" "<<pixel.Z()<<" dist on Plane "<<sqrt(pow((pixel-hitPnt).Dot(udir),2)+pow((pixel-hitPnt).Dot(vdir),2))<<" dist "<<(pixel-hitPnt).Mag()<<endl;

        cout<<"Ld mid: "; ldMid.Print();
        cout<<"U dir: "; udir.Print();
        cout<<"V dir: "; vdir.Print();
        cout<<std::endl;
    }


}
