////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// rAPPNUWSTTrackFit                                                          //
//                                                                            //
// Begin_Html <!--
/*-->

<!--*/
// --> End_Html
//                                                                            //
//                                                                            //
// Please note: The following information is only correct after executing     //
// the ROMEBuilder.                                                           //
//                                                                            //
// This task accesses the following folders :                                 //
//     GeantTrack                                                             //
//     CSMBTHit                                                               //
//     CSMTTHit                                                               //
//     RecoTracks                                                             //
//     RecoTracksBT                                                           //
//     RecoTracksTT                                                           //
//     BTTTTracksScatter                                                      //
//                                                                            //
// This task contains the following histgrams :                               //
//    HMomentum                                                               //
//    HXres                                                                   //
//    HYres                                                                   //
//    HZres                                                                   //
//                                                                            //
// The histograms/graph are created and saved automaticaly by the task.       //
//                                                                            //
// The following method can be used to get a handle of the histogram/graph :  //
//                                                                            //
// Get<Histogram/Graph Name>()                                                //
//                                                                            //
// For histogram/graph arrays use :                                           //
//                                                                            //
// Get<Histogram/Graph Name>At(Int_t index)                                   //
//                                                                            //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

/* Generated header file containing necessary includes                        */
#include "generated/rAPPNUWSTTrackFitGeneratedIncludes.h"

////////////////////////////////////////////////////////////////////////////////
/*  This header was generated by ROMEBuilder. Manual changes above the        *
 * following line will be lost next time ROMEBuilder is executed.             */
/////////////////////////////////////----///////////////////////////////////////

//#include "util/Geometry.h"
#include "tasks/rAPPNUWSTTrackFit.h"
#include "generated/rAPPNUWSAnalyzer.h"
#include "generated/rAPPNUWSRecoTracks.h"
#include "generated/rAPPNUWSRecoTracksTT.h"
#include "generated/rAPPNUWSRecoTracksBT.h"
#include "generated/rAPPNUWSGlobalSteering.h"
#include "generated/rAPPNUWSBTTTTracksScatter.h"
#include "ROMEiostream.h"
#include "TVector3.h"
#include "TMinuit.h"
#include "TClonesArray.h"
#include "TList.h"
#include "TMath.h"
#include "TF1.h"
#include "TRandom.h"

//#include "generated/rAPPNUWSDCHHit.h"
#include "generated/rAPPNUWSCSMTTHit.h"
#include "generated/rAPPNUWSCSMBTHit.h"
#include "generated/rAPPNUWSGeantTrack.h"

//#include "CellGeometryHandle.hh"
//#include "ROGeometryHandle.hh"
#include "CSMTtracker.hh"
#include "CSMBtracker.hh"
#include "CSMTTROGeometryHandle.hh"
#include "CSMBTROGeometryHandle.hh"
#include "utilFunctions.hh"

#include "CLHEP/Vector/ThreeVector.h"

#include "ConstField.h"
#include "FieldManager.h"
#include <TGeoMaterialInterface.h>
#include <MaterialEffects.h>
#include "AbsTrackRep.h"
#include "RKTrackRep.h"
//#include "Track.h"
#include "RectangularFinitePlane.h"
#include <Tools.h>
#include "KalmanFitter.h"
#include "KalmanFitterRefTrack.h"
#include "DAF.h"
#include "KalmanFitterInfo.h"
#include <KalmanFittedStateOnPlane.h>
#include "Exception.h"
//#include "WireMeasurement.h"
//#include "WirePointMeasurement.h"
#include "SpacepointMeasurement.h"
#include "PlanarMeasurement.h"
#include <EventDisplay.h>

#include <TGeoGlobalMagField.h>
#include <TGeoManager.h>
#include <TROOT.h>
#include <memory>
#include "Math/Point3D.h"
#include "Math/Vector3D.h"

using namespace genfit;

// uncomment if you want to include headers of all folders
//#include "rAPPNUWSAllFolders.h"

extern std::ostream& operator<<( std::ostream& ostr, const TVector3& f );//{return ostr<<f.X()<<" "<<f.Y()<<" "<<f.Z();}

ClassImp(rAPPNUWSTTrackFit)

using namespace std;

static const float sclfac=0.1;
static const float tomgCent=300.0; //tomographer center y, in cm

//double sgmAngle(TVector3 &mom, TMatrixDSym &cov, int id=0); //id: 0 -> Theta, 1 -> Phi
double sgmTheta(TVector3 &mom, TMatrixDSym &cov);
double sgmPhi(TVector3 &mom, TMatrixDSym &cov);
double sgmTheta1(TVector3 &mom, TMatrixDSym &cov);

//______________________________________________________________________________
void rAPPNUWSTTrackFit::Init() {

    fGeometry = GeometrySrvHndl::Instance();
    if(!fGeometry->GetCSMTTROChanHandle() || !fGeometry->GetCSMBTROChanHandle())
        fGeometry->makeDetectors();

    //init genfit
    if (gROOT->GetVersionInt()>=62400) {
        TGeoManager::LockDefaultUnits(kFALSE);
        TGeoManager::SetDefaultUnits(TGeoManager::EDefaultUnits::kRootUnits);
    }

    TGeoManager::Import(gAnalyzer->GetGSP()->GetGeomGDMLfile());
    FieldManager::getInstance()->init(new ConstField(0,0,gAnalyzer->GetGSP()->GetBz()*10.)); //kGs
    MaterialEffects* mateff=MaterialEffects::getInstance();
    //mateff->setEnergyLossBetheBloch(true);
    //mateff->setNoiseBetheBloch(true);
    //mateff->setNoiseCoulomb(true);

//    if ( GetSP()->GetDoDisplay() ) {
//        // init event display
//        genfit::EventDisplay* display = genfit::EventDisplay::getInstance();
//    }

    //disable brems effect, as it is not correct for positron in genfit
//    mateff->setEnergyLossBrems(false);
//    mateff->setNoiseBrems(false);

    mateff->init(new TGeoMaterialInterface());
    if (GetSP()->GetDebugLevel()>2) { mateff->setDebugLvl(1); }

    distCut=GetSP()->GettrckmatchDistCut();
    angleCut=GetSP()->GettrckmatchAngleCut()*TMath::DegToRad();

    //genfit::MaterialEffects::getInstance()->setNoEffects();

}

//______________________________________________________________________________
void rAPPNUWSTTrackFit::BeginOfRun() {
}

//______________________________________________________________________________
void rAPPNUWSTTrackFit::Event() {

    if (gAnalyzer->GetCurrentEventNumber()%100==0) { printf("\n rAPPNUWSTTrackFit::Event ***** Load event %lld ************************ \n",gAnalyzer->GetCurrentEventNumber()); }

    fBrHitsCSMTT=gAnalyzer->GetCSMTTHits();
    fBrHitsCSMBT=gAnalyzer->GetCSMBTHits();
    //  fBrHitsDC=gAnalyzer->GetDCHHits();
    fBrDataTrk=gAnalyzer->GetGeantTracks();

    fVert = TVector3(0.,0.,0.);

    MCFinder();

    for (unsigned int it=0; it<TTftracks.size(); ++it) {
        delete TTftracks[it];
    }
    TTftracks.clear();
    for (unsigned int it=0; it<BTftracks.size(); ++it) {
        delete BTftracks[it];
    }
    BTftracks.clear();
    for (unsigned int it=0; it<COMBBTftracks.size(); ++it) {
        delete COMBBTftracks[it];
    }
    COMBBTftracks.clear();

    if ( GetSP()->GetDoDisplay() ) {
//        for (int it=0; it<DISPftracks.size(); ++it) {
//            delete DISPftracks[it];
//        }
        DISPftracks.clear();
    }


    for(int i=0;i<gAnalyzer->GetRecoTracksTTSize();i++){
        rAPPNUWSRecoTracksTT *aTrkTT = gAnalyzer->GetRecoTracksTTAt(i);
        //    Fit(aTrk);
        Fit2TT(aTrkTT);
    }

    for(int i=0;i<gAnalyzer->GetRecoTracksBTSize();i++){
        rAPPNUWSRecoTracksBT *aTrkBT = gAnalyzer->GetRecoTracksBTAt(i);
        //    Fit(aTrk);
        Fit2BT(aTrkBT);
    }

    for(int i=0;i<gAnalyzer->GetRecoTracksSize();i++){
        rAPPNUWSRecoTracks *aTrk = gAnalyzer->GetRecoTracksAt(i);
        //    Fit(aTrk);
        Fit2(aTrk);
    }
    if ( GetSP()->GetDoDisplay() ) {
        genfit::EventDisplay::getInstance()->addEvent(DISPftracks);
    }

    FindScatter();


}

void rAPPNUWSTTrackFit::MCFinder(){
    int nprimary=0;
    std::vector<int> primaryID;
    primaryID.clear();
    Int_t nmctrack = fBrDataTrk->GetEntriesFast();
    for(int i=0;i<nmctrack;i++){
        rAPPNUWSGeantTrack* aMCTrack = ((rAPPNUWSGeantTrack*)fBrDataTrk->At(i));
        if(aMCTrack&&aMCTrack->GetfParentID()==0&&aMCTrack->GetfTrackID()>nprimary) {
            //nprimary=aMCTrack->GetfTrackID();
            primaryID.push_back(aMCTrack->GetfTrackID());
            ++nprimary;
        }
    }
    for(int i=0;i<nmctrack;i++){
        rAPPNUWSGeantTrack* aMCTrack = ((rAPPNUWSGeantTrack*)fBrDataTrk->At(i));
        if(aMCTrack->GetfParentID()>0&&aMCTrack->GetfTrackID()<=nprimary)
            std::cout<<"rAPPNUWSTTrackFit::MCFinder: Error in logic:first tracks are not only primary "<<aMCTrack->GetfTrackID()<<" "<<nprimary<<std::endl;
    }

    //  Int_t nhitsdch = fBrHitsDC->GetEntriesFast();
    //
    //  //sort by tof
    //  std::vector<std::vector<std::pair<double,int> > > hitvec(nprimary);
    //  for(int ihit=0;ihit<nhitsdch;ihit++){
    //    rAPPNUWSDCHHit *ahit = (rAPPNUWSDCHHit*) fBrHitsDC->At(ihit);
    //    //only hits beloging to primaries track
    //    int trkid=ahit->GetfTrkIDofHit();
    //    if (trkid <1 || trkid > nprimary) continue;
    //    hitvec[trkid-1].push_back(std::pair<double,int >(ahit->GetfGlobalTime(),ihit));
    //  }


    //Find hits of the primary tracks in the Top Tracker
    Int_t nhitsCSMTT = fBrHitsCSMTT->GetEntriesFast();

    //sort by tof
    std::vector<std::vector<std::pair<double,int> > > hitvec(nprimary);

    std::vector<std::vector<std::pair<double,int> > > hitvecTT(nprimary);
    for(int ihit=0;ihit<nhitsCSMTT;ihit++){
        rAPPNUWSCSMTTHit *ahit = (rAPPNUWSCSMTTHit*) fBrHitsCSMTT->At(ihit);
        //only hits beloging to primaries track
        int trkid=ahit->GetfTrkIDofHit();
        if (trkid <1 || trkid > nprimary) continue;
        hitvecTT[trkid-1].push_back(std::pair<double,int >(ahit->GetfGlobalTime(),ihit));
        hitvec[trkid-1].push_back(std::pair<double,int >(ahit->GetfGlobalTime(),ihit));
    }

    //Find hits of the primary tracks in the Bottom Tracker
    Int_t nhitsCSMBT = fBrHitsCSMBT->GetEntriesFast();

    std::vector<std::vector<std::pair<double,int> > > hitvecBT(nprimary);
    for(int ihit=0;ihit<nhitsCSMBT;ihit++){
        rAPPNUWSCSMBTHit *ahit = (rAPPNUWSCSMBTHit*) fBrHitsCSMBT->At(ihit);
        //only hits beloging to primaries track
        int trkid=ahit->GetfTrkIDofHit();
        if (trkid <1 || trkid > nprimary) continue;
        hitvecBT[trkid-1].push_back(std::pair<double,int >(ahit->GetfGlobalTime(),ihit));
        hitvec[trkid-1].push_back(std::pair<double,int >(ahit->GetfGlobalTime(),ihit+nhitsCSMTT));
    }

    if (GetSP()->GetDebugLevel()) { std::cout<</*"nhits dch "<<nhitsdch<<*/" CSMTT "<<nhitsCSMTT<<" CSMBT "<<nhitsCSMBT<<std::endl; }

    //Store identified tracks
    gAnalyzer->SetRecoTracksSize(nprimary);
    gAnalyzer->SetRecoTracksBTSize(nprimary);
    gAnalyzer->SetRecoTracksTTSize(nprimary);

    for(int i=0;i<nprimary;i++){
        //--------- global tack fitter  ---------
        rAPPNUWSRecoTracks *aTrk = gAnalyzer->GetRecoTracksAt(i);
        aTrk->SetTrkID(primaryID.at(i));
        aTrk->Getcov()->ResizeTo(6,6);

        unsigned int ntrkhits=hitvec[i].size();
        aTrk->Setnhits(ntrkhits);
        aTrk->SethitindexSize(ntrkhits);
        aTrk->SetdetidSize(ntrkhits);
        aTrk->SetIsFitted(false);
        aTrk->Getcov()->ResizeTo(6,6);

        //sort by tof
        std::sort(hitvec[i].begin(),hitvec[i].end());

        for(unsigned int ihit=0;ihit<ntrkhits;ihit++){
            int detid=hitvec[i][ihit].second<nhitsCSMTT?0:1;
            aTrk->SetdetidAt(ihit,detid);
            aTrk->SethitindexAt(ihit,hitvec[i][ihit].second/*-(detid>0?nhitsCSMTT:0)*/);
        }

        //--------- Top Tracker tack fitter  ---------
        rAPPNUWSRecoTracksTT *aTrkTT = gAnalyzer->GetRecoTracksTTAt(i);
        aTrkTT->SetTrkID(primaryID.at(i));
        aTrkTT->Getcov()->ResizeTo(6,6);

        unsigned int ntrkhitsTT=hitvecTT[i].size();
        aTrkTT->Setnhits(ntrkhitsTT);
        aTrkTT->SethitindexSize(ntrkhitsTT);
        aTrkTT->SetIsFitted(false);
        aTrkTT->Getcov()->ResizeTo(6,6);

        //sort by tof
        std::sort(hitvecTT[i].begin(),hitvecTT[i].end());

        for(unsigned int ihit=0;ihit<ntrkhitsTT;ihit++){
            aTrkTT->SethitindexAt(ihit,hitvecTT[i][ihit].second/*-(detid>0?nhitsdch:0)-(detid>1?nhitsCSMBT:0)*/);
        }

        //--------- Bottom Tracker tack fitter  ---------
        rAPPNUWSRecoTracksBT *aTrkBT = gAnalyzer->GetRecoTracksBTAt(i);
        aTrkBT->SetTrkID(primaryID.at(i));
        aTrkBT->Getcov()->ResizeTo(6,6);

        unsigned int ntrkhitsBT=hitvecBT[i].size();
        aTrkBT->Setnhits(ntrkhitsBT);
        aTrkBT->SethitindexSize(ntrkhitsBT);
        aTrkBT->SetIsFitted(false);
        aTrkBT->Getcov()->ResizeTo(6,6);

        //sort by tof
        std::sort(hitvecBT[i].begin(),hitvecBT[i].end());

        for(unsigned int ihit=0;ihit<ntrkhitsBT;ihit++){
            aTrkBT->SethitindexAt(ihit,hitvecBT[i][ihit].second/*-(detid>0?nhitsdch:0)-(detid>1?nhitsCSMBT:0)*/);
        }



        //
        //    //fit only first turn
        //    double trkdir_prev=1.;
        //    for(unsigned int ihit=0;ihit<ntrkhits;ihit++){
        //
        //      TVector3 xyz,k;
        //      int detid=hitvec[i][ihit].second<nhitsdch?0:(hitvec[i][ihit].second<nhitsdch+nhitsCSMBT?1:2);
        //
        //      if(detid==0){
        //        rAPPNUWSDCHHit *aHit = (rAPPNUWSDCHHit*) fBrHitsDC->At(hitvec[i][ihit].second);
        //
        //        xyz=TVector3(aHit->GetfEntranceX(),aHit->GetfEntranceY(),0);//aHit->GetfEntranceZ());
        //        k=TVector3(aHit->GetfEntranceMomX(),aHit->GetfEntranceMomY(),0);//aHit->GetfEntranceMomZ());
        //      }else if(detid==1){
        //        rAPPNUWSCSMBTHit *aHit = (rAPPNUWSCSMBTHit*) fBrHitsCSMBT->At(hitvec[i][ihit].second-nhitsdch);
        //
        //        xyz=TVector3(aHit->GetfEntranceX(),aHit->GetfEntranceY(),0);//aHit->GetfEntranceZ());
        //        k=TVector3(aHit->GetfEntranceMomX(),aHit->GetfEntranceMomY(),0);//aHit->GetfEntranceMomZ());
        //      }else{
        //        rAPPNUWSCSMTTHit *aHit = (rAPPNUWSCSMTTHit*) fBrHitsCSMTT->At(hitvec[i][ihit].second-nhitsdch-nhitsCSMBT);
        //
        //        xyz=TVector3(aHit->GetfEntranceX(),aHit->GetfEntranceY(),0);//aHit->GetfEntranceZ());
        //        k=TVector3(aHit->GetfEntranceMomX(),aHit->GetfEntranceMomY(),0);//aHit->GetfEntranceMomZ());
        //      }
        //
        //      double trkdir=xyz.Dot(k)/xyz.Mag()/k.Mag();
        //      if(trkdir_prev<=0&&trkdir>0){
        //        aTrk->Setnhits(ihit-1);
        //        break;
        //      }
        //      trkdir_prev=trkdir;
        //    }
    }

}


////______________________________________________________________________________
//void rAPPNUWSTTrackFit::StoreReconstructedTrack() {
//}

//______________________________________________________________________________
void rAPPNUWSTTrackFit::EndOfRun()
{
    if ( GetSP()->GetDoDisplay() ) {
        // open event display
        genfit::EventDisplay::getInstance()->open();
    }
}
//______________________________________________________________________________
void rAPPNUWSTTrackFit::Terminate() {

    for (unsigned int it=0; it<TTftracks.size(); ++it) {
        delete TTftracks[it];
    }
    TTftracks.clear();
    for (unsigned int it=0; it<BTftracks.size(); ++it) {
        delete BTftracks[it];
    }
    BTftracks.clear();
    for (unsigned int it=0; it<COMBBTftracks.size(); ++it) {
        delete COMBBTftracks[it];
    }
    COMBBTftracks.clear();

    if ( GetSP()->GetDoDisplay() ) {
//        for (int it=0; it<DISPftracks.size(); ++it) {
//            delete DISPftracks[it];
//        }
        DISPftracks.clear();
    }
}

//______________________________________________________________________________
//Bool_t rAPPNUWSTTrackFit::Fit(rAPPNUWSRecoTracks *aTrack) {
//    int fDebug=GetSP()->GetDebugLevel();//1;
//
//
//    int nhits = aTrack->Getnhits();
//
//    if (nhits < 6) {
//        printf(" ****  !!! Event not reconstructable: number of hits forr signal track less than 6!\n");
//        return false;
//    }
//
//    int trkid=0;
//    TVector3 xyzhit0,momhit0;
//    if(aTrack->GetdetidAt(0)==0){
//        rAPPNUWSDCHHit *ahit0 = (rAPPNUWSDCHHit*) fBrHitsDC->At(aTrack->GethitindexAt(0));
//        xyzhit0=0.1*TVector3(ahit0->GetfEntranceX(),ahit0->GetfEntranceY(),ahit0->GetfEntranceZ()); // mm -> cm
//        momhit0=0.001*TVector3(ahit0->GetfEntranceMomX(),ahit0->GetfEntranceMomY(),ahit0->GetfEntranceMomZ()); // MeV -> GeV
//        trkid=ahit0->GetfTrkIDofHit();
//    }else if(aTrack->GetdetidAt(0)==1){
//        rAPPNUWSCSMBTHit *ahit0 = (rAPPNUWSCSMBTHit*) fBrHitsCSMBT->At(aTrack->GethitindexAt(0));
//        xyzhit0=0.1*TVector3(ahit0->GetfEntranceX(),ahit0->GetfEntranceY(),ahit0->GetfEntranceZ()); // mm -> cm
//        momhit0=0.001*TVector3(ahit0->GetfEntranceMomX(),ahit0->GetfEntranceMomY(),ahit0->GetfEntranceMomZ()); // MeV -> GeV
//        trkid=ahit0->GetfTrkIDofHit();
//    }else{
//        rAPPNUWSCSMTTHit *ahit0 = (rAPPNUWSCSMTTHit*) fBrHitsCSMTT->At(aTrack->GethitindexAt(0));
//        xyzhit0=0.1*TVector3(ahit0->GetfEntranceX(),ahit0->GetfEntranceY(),ahit0->GetfEntranceZ()); // mm -> cm
//        momhit0=0.001*TVector3(ahit0->GetfEntranceMomX(),ahit0->GetfEntranceMomY(),ahit0->GetfEntranceMomZ()); // MeV -> GeV
//        trkid=ahit0->GetfTrkIDofHit();
//    }
//
//    //init values
//    TVector3 xyz0=xyzhit0;//fVert;
//    TVector3 pdir0=momhit0;
//    pdir0.SetMag(1.);
//    TVector3 pmom0=momhit0;//
//
//    //Do initialization of initial covariance matrix with sigma_p,sigma_angle, 1cm position
//    TMatrixDSym Cov(6); Cov.Zero();
//
//    Cov[0][0] = Cov[1][1] =Cov[2][2] = 0.1*0.1;//centimeters
//    Cov[3][3] = Cov[4][4] =Cov[5][5] = 0.001*0.001;//GeV
//
//    //-----------------------------------
//    //init positron track with parameters from first State Vector and predefined Covariance matrix
//    //-----------------------------------
//    int pdgid=11;
//    if(trkid<=fBrDataTrk->GetEntriesFast()&&trkid>0){
//        for(int i=0;i<fBrDataTrk->GetEntriesFast();i++){
//            rAPPNUWSGeantTrack* aMCTrack = ((rAPPNUWSGeantTrack*)fBrDataTrk->At(i));
//            if(aMCTrack->GetfTrackID()==trkid){
//                pdgid=aMCTrack->GetfPDGCode();
//                if(fDebug) std::cout<<"Primary track n. "<<i<<" has different PDG "<<pdgid<<std::endl;
//                break;
//            }
//        }
//    }
//
//    //
//    if(fDebug)
//        std::cout<<"set charge to pdgid ="<<pdgid<<std::endl;
//    AbsTrackRep *rep = new RKTrackRep(pdgid);
//    MeasuredStateOnPlane stateRef(rep);
//    rep->setPosMomCov(stateRef,xyz0,pmom0,Cov);
//    stateRef.setTime(0.);
//
//    //init genfit track from initial state
//    TVectorD seedState(6);
//    TMatrixDSym seedCov(6);
//    rep->get6DStateCov(stateRef, seedState, seedCov);
//    Track fitTrack(rep,seedState, seedCov);
//    fitTrack.setTimeSeed(0.);
//
//
//    //-----------------------------------------------
//    //fill hit information
//    //-----------------------------------------------
//    int nid=0;
//
//    //add vertex constrain
//    double sigmabeam=GetSP()->GetSigmaVtx();
//    if(sigmabeam>0){
//        TVectorD hitCoords(3);
//        TMatrixDSym hitCov(3);
//        for(int i=0;i<3;i++)
//            hitCoords(i)=gRandom->Gaus()*sigmabeam;
//        hitCov(0,0) = hitCov(1,1) = hitCov(2,2) = sigmabeam*sigmabeam;
//        genfit::SpacepointMeasurement* measurement = new genfit::SpacepointMeasurement(hitCoords, hitCov, 10, 100000, NULL);
//        fitTrack.insertMeasurement(measurement,nid++);
//        if(fDebug)
//            cout<<" add vertex constrain " <<hitCoords(0)<<" "<<hitCoords(1)<<" "<<hitCoords(2)<< " with +- "<<sigmabeam<<endl;
//    }
//
//    int ihit0dch=-1,ihit0CSMBT=-1,ihit0CSMTT=-1;
//    int nhitsdch=0,nhitsCSMBT=0,nhitsCSMTT=0;
//
//    for(int ihit=0;ihit<nhits;ihit++){
//
//        if(aTrack->GetdetidAt(ihit)==0){
//            if(ihit0dch<0) ihit0dch=0;
//            nhitsdch++;
//            rAPPNUWSDCHHit *ahit =(rAPPNUWSDCHHit*) fBrHitsDC->At(aTrack->GethitindexAt(ihit));
//
//            Int_t nwire=ahit->GetfCellId();
//
//            fGeometry->GetCellHandle()->SelectCellDet(nwire);
//            const CLHEP::Hep3Vector& mid   = fGeometry->GetCellHandle()->GetCellCenter();
//            const CLHEP::Hep3Vector& w     = fGeometry->GetCellHandle()->GetCellDirection();
//
//            TVector3 wire_pos(mid.x(),mid.y(),mid.z());
//            TVector3 wire_dir(w.x(),w.y(),w.z());
//
//            Double_t b_meas = ahit->GetfImpact();
//
//            //fill mesuarements
//            TVector3 p0 = 0.1*wire_pos;
//            TVector3 w_axis = wire_dir;
//            double wnorm=w_axis.Mag();
//            TVectorD hitCoords(8);
//            TMatrixDSym hitCov(8);
//            //fill wire ends
//            for(int i=0;i<3;i++){
//                hitCoords(i)=(p0+100*w_axis)(i);
//                hitCoords(i+3)=(p0-100*w_axis)(i);
//            }
//            //mesuared values dist,Z:
//            double sigmab=GetSP()->GetSigmaRPhi();
//            hitCoords(6) = b_meas*0.1+gRandom->Gaus()*sigmab;
//            //z mesuarment are relative to wire1 in direction of wire2
//            hitCoords(7) = 100.*wnorm;
//            hitCov(6,6) = sigmab*sigmab;
//            hitCov(7,7) = 100*100;
//            WireMeasurement *whit;
//            if(1==0){//use Z
//                whit=new WirePointMeasurement(hitCoords, hitCov,0,ihit,nullptr);
//            }else{
//                whit=new WireMeasurement(hitCoords, hitCov,0,ihit,nullptr);
//            }
//            whit->setLeftRightResolution(0);//1>0?1:-1);
//            fitTrack.insertMeasurement(whit,nid++);
//
//            if(fDebug>1){
//                std::cout<<"add "<<ihit<<" wire "<<nwire<<" xywire "<<p0.X()<<" "<<p0.Y()<<" "<<p0.z()
//	                 <<" bl "<<hitCoords(6)<<" sigma "<<sqrt(hitCov(6,6))<<" "<<sqrt(hitCov(7,7))<<" xyz "
//	                 <<0.1*ahit->GetfEntranceX()<<" "<<0.1*ahit->GetfEntranceY()<<" "<<0.1*ahit->GetfEntranceZ()<<" T "<<ahit->GetfGlobalTime()<<std::endl;
//            }
//        }else if(aTrack->GetdetidAt(ihit)==1){
//            if(ihit0CSMBT<0) ihit0CSMBT=0;
//            nhitsCSMBT++;
//            rAPPNUWSCSMBTHit *ahit =(rAPPNUWSCSMBTHit*) fBrHitsCSMBT->At(aTrack->GethitindexAt(ihit));
//
//            double pxlResolution=GetSP()->GetSigmaPxlVtx();
//            //double pxlResolution=GetSP()->GetSigmaPxlPreshower();
//            TMatrixDSym hitpxlCov(2);
//            hitpxlCov.UnitMatrix();
//            hitpxlCov *= pxlResolution*pxlResolution;
//
//            TVector3 pixel(0.1*ahit->GetfEntranceX(),0.1*ahit->GetfEntranceY(),0.1*ahit->GetfEntranceZ());
//            TVectorD hitCoords(2);
//            hitCoords[0] = gRandom->Gaus()*pxlResolution;
//            hitCoords[1] = gRandom->Gaus()*pxlResolution;
//            genfit::PlanarMeasurement* measurement = new genfit::PlanarMeasurement(hitCoords, hitpxlCov, 1, ihit, nullptr);
//            TVector3 vdir(-pixel.Y(),pixel.X(),0);vdir.SetMag(1);
//            measurement->setPlane(genfit::SharedPlanePtr(new genfit::DetPlane(TVector3(pixel.X(),pixel.Y(),pixel.Z()), vdir, TVector3(0,0,1))), 0);
//            fitTrack.insertMeasurement(measurement,nid++);
//            if(fDebug>1) {
//                cout<<" add "<<ihit<<" VTX mes "<<hitCoords[0]<<" "<<hitCoords[1]
//                                                                               <<" xyz "<<pixel.X()<<" "<<pixel.Y()<<" "<<pixel.Z()<< " with +- "<<pxlResolution<<" T "<<ahit->GetfGlobalTime()<<endl;
//                cout<<"U dir: "; vdir.Print();
//                cout<<"V dir: "; TVector3(0,0,1).Print();
//            }
//        }else{
//            if(ihit0CSMBT<0) ihit0CSMBT=0;
//            nhitsCSMTT++;
//            rAPPNUWSCSMTTHit *ahit =(rAPPNUWSCSMTTHit*) fBrHitsCSMTT->At(aTrack->GethitindexAt(ihit));
//
//            //double pxlResolution=GetSP()->GetSigmaPxlVtx();
//            double pxlResolution=GetSP()->GetSigmaPxlPreshower();
//            TMatrixDSym hitpxlCov(2);
//            hitpxlCov.UnitMatrix();
//            hitpxlCov *= pxlResolution*pxlResolution;
//
//            TVector3 pixel(0.1*ahit->GetfEntranceX(),0.1*ahit->GetfEntranceY(),0.1*ahit->GetfEntranceZ());
//            TVectorD hitCoords(2);
//            hitCoords[0] = gRandom->Gaus()*pxlResolution;
//            hitCoords[1] = gRandom->Gaus()*pxlResolution;
//            genfit::PlanarMeasurement* measurement = new genfit::PlanarMeasurement(hitCoords, hitpxlCov, 2, ihit, nullptr);
//            TVector3 vdir(-pixel.Y(),pixel.X(),0);vdir.SetMag(1);
//            measurement->setPlane(genfit::SharedPlanePtr(new genfit::DetPlane(TVector3(pixel.X(),pixel.Y(),pixel.Z()), vdir, TVector3(0,0,1))), 0);
//            fitTrack.insertMeasurement(measurement,nid++);
//            if(fDebug>1)
//                cout<<" add "<<ihit<<" CSMTT mes "<<hitCoords[0]<<" "<<hitCoords[1]
//                                                                                 <<" xyz "<<pixel.X()<<" "<<pixel.Y()<<" "<<pixel.Z()<< " with +- "<<pxlResolution<<" T "<<ahit->GetfGlobalTime()<<endl;
//
//        }
//    }
//
//
//
//    // ---- end of hit info filling ------------------------
//
//
//    //  assert(fitTrack.checkConsistency());
//    fitTrack.checkConsistency();
//    genfit::FitStatus* fitStatus=fitTrack.getFitStatus(rep);
//    if(fDebug){
//        std::cout<<" init chi2 "<<fitStatus->getChi2()<<" nfailed "<<fitStatus->getNFailedPoints()
//                     <<" P= "<<rep->getMomMag(stateRef)*rep->getCharge(stateRef)<<" +- "<<sqrt(rep->getMomVar(stateRef))
//                     <<" nhits "<<nid<<" from "<<nhits<<" dch "<<nhitsdch<<" CSMBT "<<nhitsCSMBT<<" CSMTT "<<nhitsCSMTT<<std::endl;
//        std::cout<<"init state "<<xyz0<<" "<<pmom0<<endl;
//    }
//
//    //choose different fitter
//    genfit::AbsKalmanFitter* fitter = 0;
//    switch(0/*GetSP()->GetKalmanType()*/){
//    case 0:
//        fitter=new DAF();
//        break;
//    case 1:
//        fitter=new KalmanFitterRefTrack(20);
//        break;
//    case 2:
//        fitter=new KalmanFitter(20);
//        break;
//    }
//    /*
//  if(GetSP()->GetKalmanType()>0){
//    //use LR from patter recognition in case of usual KalmanFitter
//    fitter->setMultipleMeasurementHandling(genfit::weightedClosestToPredictionWire);
//  }*/
//
//    if(kDebug>20){
//        fitter->setDebugLvl(10);
//        rep->setDebugLvl(10);
//    }
//
//    //-----------------------------------
//    // FIT IT
//    //-----------------------------------
//    //cout<<"-----------1-------------"<<endl;
//    try{
//        fitter->processTrack(&fitTrack);
//    }catch(Exception& e){
//        if(fDebug) std::cout<<"on fitting "<<e.what()<<std::endl;
//    }
//    //cout<<"-----------2-------------"<<endl;
//    fitStatus=fitTrack.getFitStatus(rep);
//    bool fitstatus=fitStatus->isFitConverged()&&(fitStatus->getNFailedPoints()==0);
//    if(fDebug) fitStatus->Print();
//    //cout<<"-----------3-------------"<<endl;
//
//
//    TVector3 pos,mom;
//    TMatrixDSym cov(6);
//    TVector3 pos2,mom2;
//    TMatrixDSym cov2(6);
//    double pmom=0;
//    double tof=0;
//    double sigmap=0.;
//
//    //-----------------------------------
//    // fill info from first hit
//    //-----------------------------------
//
//    try{
//        const MeasuredStateOnPlane& stFirst=fitTrack.getFittedState();
//        pmom=rep->getMomMag(stFirst)*rep->getCharge(stFirst);
//        stFirst.getPosMomCov(pos,mom,cov);
//        tof=stFirst.getTime();
//    }catch(Exception& e){
//        if(fDebug) std::cout<<"on getting state "<<e.what()<<std::endl;
//    }
//
//
//    if(fDebug)
//        std::cout<<" chi2 "<<fitStatus->getChi2()<<" nfailed "<<fitStatus->getNFailedPoints()
//        <<" P= "<<pmom<<" fitok="<<fitstatus<<std::endl;
//
//    if(fDebug){std::cout<<"fitted xyz "<<pos<<" mom "<<mom<<endl;}
//
//    //-----------------------------------
//    //set states on hits
//    //-----------------------------------
//
//    unsigned int numhits = fitTrack.getNumPoints();
//
//    int ngoodhits=0;
//    int ngoodhitsdch=0,ngoodhitsCSMBT=0,ngoodhitsCSMTT=0;
//    double sumddist=0;
//
//    aTrack->SetStateVectorSize(nhits);
//    aTrack->GetSkipped().resize(nhits,true);
//
//    if(fitstatus){
//        try{
//            for(unsigned int jhit=0;jhit<numhits;jhit++){
//                TrackPoint* point = fitTrack.getPoint(jhit);
//                int ihit=point->getRawMeasurement(0)->getHitId();
//                int detid=point->getRawMeasurement(0)->getDetId();
//                //skip virtual hit
//                //        if(ihit>=1000) continue;
//
//                //skip point without fitted information
//                if(!point->hasFitterInfo(rep)) continue;
//
//                KalmanFitterInfo* fi = static_cast<KalmanFitterInfo*>(point->getFitterInfo(rep));
//                //get weights for LR combinations
//                std::vector<double> dafWeights = fi->getWeights();
//
//                //maximum weigth in fitting from LR positions
//                int imaxdaf=std::distance(dafWeights.begin(),
//                        std::max_element(dafWeights.begin(),dafWeights.end()));
//                double maxdaf=dafWeights[imaxdaf];
//
//
//                //fill histogram with final chi2 per hit
//                const MeasurementOnPlane& residual = fi->getResidual(imaxdaf, false, false);
//                const TVectorD& resid(residual.getState());
//
//                //dont fill StateVector forr skipped hits during fitting(in normal case hit must have weight=1.)
//                if(maxdaf<0.5) {
//                    if(fDebug>9) std::cout<<"skip point "<<endl;
//                    continue;
//                }
//
//                //fill biased best StateVector on hit
//                // (averaged from forward-backward propagation)
//                const MeasuredStateOnPlane& state=fi->getFittedState(true);
//                state.getPosMomCov(pos,mom,cov);
//
//                //unbiased
//                const MeasuredStateOnPlane& state2=fi->getFittedState(false);
//                state2.getPosMomCov(pos2,mom2,cov2);
//
//                if(detid==0){
//                    //average T0 shift over hits
//                    sumddist+=resid(0)*(imaxdaf?1:-1);
//                    ngoodhitsdch++;
//                }else if(detid==1){
//                    ngoodhitsCSMBT++;
//                }else if(detid==2){
//                    ngoodhitsCSMTT++;
//                }
//
//                if(detid<10){ //wire or CSMBT or CSMTT hit
//                    aTrack->SetSkippedAt(ihit,false);
//                    *aTrack->GetStateVectorAt(ihit)=pos;
//                    ngoodhits++;
//                    if(detid==0){
//                        rAPPNUWSDCHHit *ahit = (rAPPNUWSDCHHit*) fBrHitsDC->At(aTrack->GethitindexAt(ihit));
//                        if(fDebug>9)
//                            cout<<detid<<" "<<ihit<<" track aver "<<state.getState()(3)<<" mes "<<0.1*ahit->GetfImpact()<<" dR not biased "<<resid(0)
//                            <<" biased "<<0.1*ahit->GetfImpact()-fabs(state.getState()(3))<<" trk xyz "<<pos<<" mom "<<mom.Y()<<endl;
//                        GetHResidualUnbiased()->Fill(10*fabs(state.getState()(3)),10*resid(0));
//                        GetHResidualBiased()->Fill(10*fabs(state.getState()(3)),ahit->GetfImpact()-10*fabs(state.getState()(3)));
//                    }else if(detid==1){
//                        rAPPNUWSCSMBTHit *ahit = (rAPPNUWSCSMBTHit*) fBrHitsCSMBT->At(aTrack->GethitindexAt(ihit));
//                        if(fDebug>9)
//                            cout<<detid<<" "<<ihit<<" track aver "<<state.getState()(3)<<" "<<state.getState()(4)<<" exact mes 0 0 dy,dz not biased "<<resid(0)<<" "<<resid(1)
//                            <<" trk xyz "<<pos<<" mom "<<mom.Y()<<endl;
//                    }else if(detid==2){
//                        rAPPNUWSCSMTTHit *ahit = (rAPPNUWSCSMTTHit*) fBrHitsCSMTT->At(aTrack->GethitindexAt(ihit));
//                        if(fDebug>9)
//                            cout<<detid<<" "<<ihit<<" track aver "<<state.getState()(3)<<" "<<state.getState()(4)<<" exact mes 0 0 dy,dz not biased "<<resid(0)<<" "<<resid(1)
//                            <<" trk xyz "<<pos<<" mom "<<mom.Y()<<endl;
//                    }
//                }
//                // state.Print();
//                // cov.Print();
//                // state2.Print();
//                // cov2.Print();
//                if(ihit==aTrack->GethitindexAt(0))
//                    if(IsHMomentumActive()) GetHMomentum()->Fill(pmom0.Mag(),mom.Mag()/pmom0.Mag()-1);
//                if(fDebug>9) {
//                    std::cout<<jhit<<" detid "<<detid<<" id "<<ihit<<" at hit "<<pos<<" "<<mom<<endl;
//                }
//            }
//        }catch(Exception& e){
//            if(fDebug) std::cout<<"on getting points "<<e.what()<<std::endl;
//            fitstatus=false;
//        }
//        sumddist/=ngoodhitsdch;
//        if(fDebug) std::cout<<" filtrated hits "<<numhits-ngoodhits<<" average ddist "<<sumddist/(0.4/150e-9)<<std::endl;
//    }
//
//
//    //-----------------------------------
//    //propagate to target
//    //-----------------------------------
//    if(fitstatus){
//
//        //force backward propagation(will be working forr only finite plane
//        rep->setPropDir(-1);
//        //take first fitted point
//        TrackPoint* tp = fitTrack.getPointWithFitterInfo(0);
//        if (tp == NULL) {std::cout << "Track has no TrackPoint with fitterInfo!(but fitstatus ok?)"<<std::endl;}
//        KalmanFitterInfo* fi = static_cast<KalmanFitterInfo*>(tp->getFitterInfo(rep));
//        MeasuredStateOnPlane state;
//
//        //extrapolate rep to target plane
//        bool isattarget=true;
//        try{
//            state=fi->getFittedState(true);
//            rep->extrapolateToLine(state,TVector3(0,0,0),TVector3(0,0,1));
//        }catch(Exception& e){
//            if(fDebug) std::cout<<"on extrapolation to beam line "<<e.what()<<std::endl;
//            isattarget=false;
//        }
//        double tof_target=1e9;
//        if(isattarget){
//            tof_target=state.getTime();
//            state.getPosMomCov(pos,mom,cov);
//            double momrec=mom.Mag();
//            sigmap=momrec*momrec*TMath::Sqrt(state.getCov()(0,0));
//
//        }
//        if(fDebug)
//            std::cout<<"vertex chi2 "<<fitStatus->getChi2()<<" ndf "<<fitStatus->getNdf()
//            <<" nhits "<<nhits<<" dch "<<nhitsdch<<" CSMBT "<<nhitsCSMBT<<" CSMTT "<<nhitsCSMTT<<" nfailed "<<fitStatus->getNFailedPoints()
//            <<" P= "<<mom.Mag()*rep->getCharge(state)<<" +- "<<sigmap<<" fitok="<<fitstatus
//            <<" pos "<<pos<<" mom "<<mom<<std::endl;
//    }
//
//    aTrack->Setx0(pos.X()*10);
//    aTrack->Seterr_x0(sqrt(cov(0,0))*10);
//    aTrack->Sety0(pos.Y()*10);
//    aTrack->Seterr_y0(sqrt(cov(1,1))*10);
//    aTrack->Setz0(pos.Z()*10);
//    aTrack->Seterr_z0(sqrt(cov(2,2))*10);
//    aTrack->Settheta(mom.Theta());
//    aTrack->Seterr_theta(0.);
//    aTrack->Setphi(mom.Phi());
//    aTrack->Seterr_phi(0.);
//    aTrack->SetMomentum(mom.Mag());
//    aTrack->SetErr_Momentum(sigmap);
//    aTrack->Setmom(mom);
//    aTrack->Getcov()->ResizeTo(6,6);
//    aTrack->Setcov(cov);
//
//    //fill final information
//    aTrack->Setnhits(nhits);
//    aTrack->Setnhitsdch(nhitsdch);
//    aTrack->SetnhitsCSMBT(nhitsCSMBT);
//    aTrack->SetnhitsCSMTT(nhitsCSMTT);
//    aTrack->Setchi2(fitStatus->getChi2());
//    aTrack->Setdof(fitStatus->getNdf());
//    aTrack->Setngoodhits(ngoodhits);
//    aTrack->Setngoodhitsdch(ngoodhitsdch);
//    aTrack->SetngoodhitsCSMBT(ngoodhitsCSMBT);
//    aTrack->SetngoodhitsCSMTT(ngoodhitsCSMTT);
//    aTrack->SetIsFitted(fitstatus);
//
//
//    delete fitter;
//
//    return true;
//}

//______________________________________________________________________________
Bool_t rAPPNUWSTTrackFit::Fit2(TObject *tmpTrack) {
    int fDebug=GetSP()->GetDebugLevel();//1;

    int trkid=0;
    TVector3 xyzhit0,momhit0;
    int nhits = 0;

    rAPPNUWSRecoTracks *aTrack = (rAPPNUWSRecoTracks *)tmpTrack;

    nhits = aTrack->Getnhits();
    if (nhits < 5) {
        if (fDebug>1) printf(" ****  !!! Event %lld not reconstructable: number of hits for TT and BT signal track less than 5!\n",gAnalyzer->GetCurrentEventNumber());
        return false;
    }

    if (aTrack->GetdetidAt(0)==0) {

        rAPPNUWSCSMTTHit *ahit0 = (rAPPNUWSCSMTTHit*) fBrHitsCSMTT->At(aTrack->GethitindexAt(0));
        xyzhit0=sclfac*TVector3(ahit0->GetfEntranceX(),ahit0->GetfEntranceY(),ahit0->GetfEntranceZ()); // mm -> cm
        momhit0=0.001*TVector3(ahit0->GetfEntranceMomX(),ahit0->GetfEntranceMomY(),ahit0->GetfEntranceMomZ()); // MeV -> GeV
        trkid=ahit0->GetfTrkIDofHit();

    } else if (aTrack->GetdetidAt(0)==1) {

        int hitInd = aTrack->GethitindexAt(0)-fBrHitsCSMTT->GetEntriesFast();
        rAPPNUWSCSMBTHit *ahit0 = (rAPPNUWSCSMBTHit*) fBrHitsCSMBT->At(hitInd);
        xyzhit0=sclfac*TVector3(ahit0->GetfEntranceX(),ahit0->GetfEntranceY(),ahit0->GetfEntranceZ()); // mm -> cm
        momhit0=0.001*TVector3(ahit0->GetfEntranceMomX(),ahit0->GetfEntranceMomY(),ahit0->GetfEntranceMomZ()); // MeV -> GeV
        trkid=ahit0->GetfTrkIDofHit();

    }

    //init values
    TVector3 xyz0=xyzhit0;//fVert;
    TVector3 pdir0=momhit0;
    pdir0.SetMag(1.);
    TVector3 pmom0=momhit0;//

    //Do initialization of initial covariance matrix with sigma_p,sigma_angle, 1cm position
    TMatrixDSym Cov(6); Cov.Zero();

    Cov[0][0] = Cov[1][1] =Cov[2][2] = sclfac*sclfac;//centimeters
    Cov[3][3] = Cov[4][4] =Cov[5][5] = 0.001*0.001;//GeV

    //-----------------------------------
    //init positron track with parameters from first State Vector and predefined Covariance matrix
    //-----------------------------------
    int pdgid=13;
    if(trkid<=fBrDataTrk->GetEntriesFast()&&trkid>0){
        for(int i=0;i<fBrDataTrk->GetEntriesFast();i++){
            rAPPNUWSGeantTrack* aMCTrack = ((rAPPNUWSGeantTrack*)fBrDataTrk->At(i));
            if(aMCTrack->GetfTrackID()==trkid){
                if (pdgid!=aMCTrack->GetfPDGCode()) {
                    pdgid=aMCTrack->GetfPDGCode();
                    if(fDebug) std::cout<<"Primary track n. "<<i<<" has different PDG "<<pdgid<<std::endl;
                    break;
                }
            }
        }
    }

    //
    if(fDebug)
        std::cout<<"set charge to pdgid ="<<pdgid<<std::endl;
    AbsTrackRep *rep = new RKTrackRep(pdgid);
    MeasuredStateOnPlane stateRef(rep);
    rep->setPosMomCov(stateRef,xyz0,pmom0,Cov);
    stateRef.setTime(0.);

    //init genfit track from initial state
    TVectorD seedState(6);
    TMatrixDSym seedCov(6);
    rep->get6DStateCov(stateRef, seedState, seedCov);
    Track fitTrack(rep,seedState, seedCov);
    fitTrack.setTimeSeed(0.);


    //-----------------------------------------------
    //fill hit information
    //-----------------------------------------------
    int nid=0;

//    //add vertex constrain
//    double sigmabeam=GetSP()->GetSigmaVtx();
//    if(sigmabeam>0){
//        TVectorD hitCoords(3);
//        TMatrixDSym hitCov(3);
//        for(int i=0;i<3;i++)
//            hitCoords(i)=gRandom->Gaus()*sigmabeam;
//        hitCov(0,0) = hitCov(1,1) = hitCov(2,2) = sigmabeam*sigmabeam;
//        genfit::SpacepointMeasurement* measurement = new genfit::SpacepointMeasurement(hitCoords, hitCov, 10, 100000, NULL);
//        fitTrack.insertMeasurement(measurement,nid++);
//        if(fDebug)
//            cout<<" add vertex constrain " <<hitCoords(0)<<" "<<hitCoords(1)<<" "<<hitCoords(2)<< " with +- "<<sigmabeam<<endl;
//    }

    int /*ihit0dch=-1,*/ihit0CSMBT=-1,ihit0CSMTT=-1;
    int /*nhitsdch=0,*/nhitsCSMBT=0,nhitsCSMTT=0;

    for(int ihit=0;ihit<nhits;ihit++){

        rAPPNUWSRecoTracks *aTrack = (rAPPNUWSRecoTracks *)tmpTrack;

        if (aTrack->GetdetidAt(ihit)==0) {

            rAPPNUWSCSMTTHit *ahit = (rAPPNUWSCSMTTHit*) fBrHitsCSMTT->At(aTrack->GethitindexAt(ihit));
            addTThit (ahit, ihit, ihit0CSMTT, nhitsCSMTT, fitTrack/*, nid*/);

        } else if (aTrack->GetdetidAt(ihit)==1) {

            int hitInd = aTrack->GethitindexAt(ihit)-fBrHitsCSMTT->GetEntriesFast();
            rAPPNUWSCSMBTHit *ahit = (rAPPNUWSCSMBTHit*) fBrHitsCSMBT->At(hitInd);
            addBThit (ahit, ihit, ihit0CSMBT, nhitsCSMBT, fitTrack/*, nid*/);

        }

    }

    // ---- end of hit info filling ------------------------


    //  assert(fitTrack.checkConsistency());
    fitTrack.checkConsistency();
    genfit::FitStatus* fitStatus=fitTrack.getFitStatus(rep);
    if(fDebug){
        std::cout<<" init chi2 "<<fitStatus->getChi2()<<" nfailed "<<fitStatus->getNFailedPoints()
                     <<" P= "<<rep->getMomMag(stateRef)*rep->getCharge(stateRef)<<" +- "<<sqrt(rep->getMomVar(stateRef))
                     <<" nhits "<<nid<<" from "<<nhits/*<<" dch "<<nhitsdch*/<<" CSMBT "<<nhitsCSMBT<<" CSMTT "<<nhitsCSMTT<<std::endl;
        std::cout<<"init state ";xyz0.Print();std::cout<<" ";pmom0.Print();std::cout<<endl;
    }

    //choose different fitter
    genfit::AbsKalmanFitter* fitter = 0;
    switch(0/*GetSP()->GetKalmanType()*/){
    case 0:
        fitter=new DAF();
        break;
    case 1:
        fitter=new KalmanFitterRefTrack(20);
        break;
    case 2:
        fitter=new KalmanFitter(20);
        break;
    }
    /*
  if(GetSP()->GetKalmanType()>0){
    //use LR from patter recognition in case of usual KalmanFitter
    fitter->setMultipleMeasurementHandling(genfit::weightedClosestToPredictionWire);
  }*/

    if(fDebug>20){
        fitter->setDebugLvl(10);
        rep->setDebugLvl(10);
    }

    //-----------------------------------
    // FIT IT
    //-----------------------------------

    try{
        fitter->processTrack(&fitTrack);
    }catch(Exception& e){
        if(fDebug) std::cout<<"on fitting "<<e.what()<<std::endl;
    }
    fitStatus=fitTrack.getFitStatus(rep);
    bool fitstatus=fitStatus->isFitConverged()&&(fitStatus->getNFailedPoints()==0);
    if(fDebug) fitStatus->Print();


    TVector3 pos,mom;
    TMatrixDSym cov(6);
    TVector3 pos1,mom1;
    TMatrixDSym cov1(6);
    double pmom=0;
    double tof=0;
    double sigmap=0.;

    //-----------------------------------
    // fill info from first hit
    //-----------------------------------

    try{
        const MeasuredStateOnPlane& stFirst=fitTrack.getFittedState();
        pmom=rep->getMomMag(stFirst)*rep->getCharge(stFirst);
        stFirst.getPosMomCov(pos,mom,cov);
        tof=stFirst.getTime();
    }catch(Exception& e){
        if(fDebug) std::cout<<"on getting state "<<e.what()<<std::endl;
    }


    if(fDebug) {
        std::cout<<" chi2 "<<fitStatus->getChi2()<<" nfailed "<<fitStatus->getNFailedPoints()
        <<" P= "<<pmom<<" fitok="<<fitstatus<<std::endl;
    }

    if(fDebug){std::cout<<"fitted xyz ";pos.Print();std::cout<<" mom ";mom.Print();std::cout<<endl;}

    //-----------------------------------
    //set states on hits
    //-----------------------------------

    unsigned int numhits = fitTrack.getNumPoints();

    int ngoodhits=0;
    int /*ngoodhitsdch=0,*/ngoodhitsCSMBT=0,ngoodhitsCSMTT=0;
//    double sumddist=0;

    aTrack->SetStateVectorSize(nhits);
    aTrack->GetSkipped().resize(nhits,true);

    if(fitstatus){
        try{

            for(unsigned int jhit=0;jhit<numhits;jhit++){
                TrackPoint* point = fitTrack.getPoint(jhit);
                int ihit=point->getRawMeasurement(0)->getHitId();
                int idetid=point->getRawMeasurement(0)->getDetId();
                //skip virtual hit
                //        if(ihit>=1000) continue;

                //skip point without fitted information
                if(!point->hasFitterInfo(rep)) continue;

                KalmanFitterInfo* fi = static_cast<KalmanFitterInfo*>(point->getFitterInfo(rep));
                //get weights for LR combinations
                std::vector<double> dafWeights = fi->getWeights();

                //maximum weigth in fitting from LR positions
                int imaxdaf=std::distance(dafWeights.begin(),
                        std::max_element(dafWeights.begin(),dafWeights.end()));
                double maxdaf=dafWeights[imaxdaf];


                //fill histogram with final chi2 per hit
                const MeasurementOnPlane& residual = fi->getResidual(imaxdaf, false, false);
                const TVectorD& resid(residual.getState());

                //dont fill StateVector forr skipped hits during fitting(in normal case hit must have weight=1.)
                if(maxdaf<0.5) {
                    if(fDebug>9) std::cout<<"skip point "<<endl;
                    continue;
                }

                //fill biased best StateVector on hit
                // (averaged from forward-backward propagation)
                const MeasuredStateOnPlane& state=fi->getFittedState(true);
                state.getPosMomCov(pos,mom,cov);

//                //unbiased
//                const MeasuredStateOnPlane& state2=fi->getFittedState(false);
//                state2.getPosMomCov(pos2,mom2,cov2);

                /*if(idetid==0){
                    //average T0 shift over hits
                    sumddist+=resid(0)*(imaxdaf?1:-1);
                    ngoodhitsdch++;
                }else*/
                if(idetid==0){
                    ngoodhitsCSMTT++;
                }else if(idetid==1){
                    ngoodhitsCSMBT++;
                }

                if(idetid<10){ //CSMTT or CSMBT hit
                    aTrack->SetSkippedAt(ihit,false);
                    *aTrack->GetStateVectorAt(ihit)=pos;
                    ngoodhits++;
                    /*if(idetid==0){
                        rAPPNUWSDCHHit *ahit = (rAPPNUWSDCHHit*) fBrHitsDC->At(aTrack->GethitindexAt(ihit));
                        if(fDebug>9)
                            cout<<idetid<<" "<<ihit<<" track aver "<<state.getState()(3)<<" mes "<<0.1*ahit->GetfImpact()<<" dR not biased "<<resid(0)
                            <<" biased "<<0.1*ahit->GetfImpact()-fabs(state.getState()(3))<<" trk xyz "<<pos<<" mom "<<mom.Y()<<endl;
                        GetHResidualUnbiased()->Fill(10*fabs(state.getState()(3)),10*resid(0));
                        GetHResidualBiased()->Fill(10*fabs(state.getState()(3)),ahit->GetfImpact()-10*fabs(state.getState()(3)));
                    }else*/
                    if(idetid==0){
//                        rAPPNUWSCSMTTHit *ahit = (rAPPNUWSCSMTTHit*) fBrHitsCSMTT->At(aTrack->GethitindexAt(ihit));
                        if(fDebug>9) {
                            cout<<idetid<<" "<<ihit<<" track aver "<<state.getState()(3)<<" "<<state.getState()(4)<<" exact mes 0 0 dy,dz not biased "<<resid(0)<<" "<<resid(1)
                            <<" trk xyz ";pos.Print();std::cout<<" mom "<<mom.Y()<<endl;
                        }
                    } else if(idetid==1){
//                        rAPPNUWSCSMBTHit *ahit = (rAPPNUWSCSMBTHit*) fBrHitsCSMBT->At(aTrack->GethitindexAt(ihit));
                        if(fDebug>9) {
                            cout<<idetid<<" "<<ihit<<" track aver "<<state.getState()(3)<<" "<<state.getState()(4)<<" exact mes 0 0 dy,dz not biased "<<resid(0)<<" "<<resid(1)
                            <<" trk xyz ";pos.Print();std::cout<<" mom "<<mom.Y()<<endl;
                        }
                    }
                }
                // state.Print();
                // cov.Print();
                // state2.Print();
                // cov2.Print();
//                if(ihit==aTrack->GethitindexAt(0))
//                    if(IsHMomentumActive()) GetHMomentum()->Fill(pmom0.Mag(),mom.Mag()/pmom0.Mag()-1);
                if(fDebug>9) {
                    std::cout<<jhit<<" idetid "<<idetid<<" id "<<ihit<<" at hit ";pos.Print();std::cout<<" ";mom.Print();std::cout<<endl;
                }
            }
        }catch(Exception& e){
            if(fDebug) std::cout<<"on getting points "<<e.what()<<std::endl;
            fitstatus=false;
        }
//        sumddist/=ngoodhitsdch;
        if(fDebug) std::cout<<" filtrated hits "<<numhits-ngoodhits/*<<" average ddist "<<sumddist/(0.4/150e-9)*/<<std::endl;
    }


    //-----------------------------------
    //propagate to
    //-----------------------------------
    if(fitstatus){

        //force backward propagation(will be working forr only finite plane
        rep->setPropDir(0);
        //take first fitted point
        TrackPoint* tp = fitTrack.getPointWithFitterInfo(0);
        if (tp == NULL) {std::cout << "Track has no TrackPoint with fitterInfo!(but fitstatus ok?)"<<std::endl;}
        KalmanFitterInfo* fi = static_cast<KalmanFitterInfo*>(tp->getFitterInfo(rep));
        MeasuredStateOnPlane state;

        bool isUp=true;
        try{
            state=fi->getFittedState(true);
//            rep->extrapolateToLine(state,TVector3(0,fGeometry->GetCSMTtracker()->distOut()*sclfac,0),TVector3(0,0,1));

            rep->extrapolateToPlane ( state, genfit::SharedPlanePtrCreator::getPlanePtr(
                                                             new genfit::DetPlane(
                                                                   TVector3(0,fGeometry->GetCSMTtracker()->distOut()*sclfac,0),
                                                                   TVector3(0,1,0)
                                                             )
                                             )
                                     ,false
                                     ,true
                                    );

        }catch(Exception& e){
            if(fDebug) std::cout<<"on extrapolation to center line "<<e.what()<<std::endl;
            isUp=false;
        }
//        double tof_target=1e9;
        if(isUp){
//            tof_target=state.getTime();
            state.getPosMomCov(pos,mom,cov);
            double momrec=mom.Mag();
            sigmap=momrec*momrec*TMath::Sqrt(state.getCov()(0,0));

        }
        if(fDebug) {
            std::cout<<"vertex chi2 "<<fitStatus->getChi2()<<" ndf "<<fitStatus->getNdf()
            <<" nhits "<<nhits/*<<" dch "<<nhitsdch*/<<" CSMTT "<<nhitsCSMTT<<" nfailed "<<fitStatus->getNFailedPoints()
            <<" P= "<<mom.Mag()*rep->getCharge(state)<<" +- "<<sigmap<<" fitok="<<fitstatus
            <<" pos "; pos.Print();
            std::cout<<" mom "; mom.Print();
            //std::cout<<std::endl;
        }

        //extrapolate to Bottom face of the Bottom Tracker
        rep->setPropDir(0);
        bool isBt=true;
        try{
            state=fi->getFittedState(true);
//            rep->extrapolateToLine(state,TVector3(0,fGeometry->GetCSMBtracker()->distIn()*sclfac,0),TVector3(0,0,1));

            rep->extrapolateToPlane ( state, genfit::SharedPlanePtrCreator::getPlanePtr(
                                                             new genfit::DetPlane(
                                                                   TVector3(0,fGeometry->GetCSMBtracker()->distIn()*sclfac,0),
                                                                   TVector3(0,1,0)
                                                             )
                                             )
                                     ,false
                                     ,true
                                    );

        }catch(Exception& e){
            if(fDebug) std::cout<<"on extrapolation to center line "<<e.what()<<std::endl;
            isBt=false;
        }
//        double tof_target=1e9;
        if(isBt){
//            tof_target=state.getTime();
            state.getPosMomCov(pos1,mom1,cov1);
        }

    }

//    aTrack->Setx0(pos.X()/sclfac);
//    aTrack->Seterr_x0(sqrt(cov(0,0))/sclfac);
//    aTrack->Sety0(pos.Y()/sclfac);
//    aTrack->Seterr_y0(sqrt(cov(1,1))/sclfac);
//    aTrack->Setz0(pos.Z()/sclfac);
//    aTrack->Seterr_z0(sqrt(cov(2,2))/sclfac);

    pos*=1.0/sclfac;
    aTrack->Setpos0(pos);
    for (int ic=0; ic<3; ++ic) { aTrack->SeterrPos0At(ic, sqrt(cov(ic,ic))/sclfac); }

    aTrack->Settheta(mom.Theta());
    aTrack->Seterr_theta(0.);
    aTrack->Setphi(mom.Phi());
    aTrack->Seterr_phi(0.);
    aTrack->SetMomentum(mom.Mag());
    aTrack->SetErr_Momentum(sigmap);
    aTrack->Setmom(mom);
//    aTrack->Setmom(ROOT::Math::XYZVector(mom.X(),mom.Y(),mom.Z()) );
    aTrack->Getcov()->ResizeTo(6,6);
    aTrack->Setcov(cov);

//    aTrack->Setx1(pos1.X()/sclfac);
//    aTrack->Seterr_x1(sqrt(cov1(0,0))/sclfac);
//    aTrack->Sety1(pos1.Y()/sclfac);
//    aTrack->Seterr_y1(sqrt(cov1(1,1))/sclfac);
//    aTrack->Setz1(pos1.Z()/sclfac);
//    aTrack->Seterr_z1(sqrt(cov1(2,2))/sclfac);

    pos1*=1.0/sclfac;
    aTrack->Setpos1(pos1);
    for (int ic=0; ic<3; ++ic) { aTrack->SeterrPos1At(ic, sqrt(cov1(ic,ic))/sclfac); }
    aTrack->Settheta(mom1.Theta());
    aTrack->Seterr_theta(0.);
    aTrack->Setphi(mom1.Phi());
    aTrack->Seterr_phi(0.);

    //fill final information
    aTrack->Setnhits(nhits);
//    aTrack->Setnhitsdch(nhitsdch);
    aTrack->SetnhitsBT(nhitsCSMBT);
    aTrack->SetnhitsTT(nhitsCSMTT);
    aTrack->Setchi2(fitStatus->getChi2());
    aTrack->Setdof(fitStatus->getNdf());
    aTrack->Setngoodhits(ngoodhits);
//    aTrack->Setngoodhitsdch(ngoodhitsdch);
    aTrack->SetngoodhitsBT(ngoodhitsCSMBT);
    aTrack->SetngoodhitsTT(ngoodhitsCSMTT);
    aTrack->SetIsFitted(fitstatus);

    COMBBTftracks.push_back(new genfit::Track(fitTrack) );
    if ( GetSP()->GetDoDisplay() ) {
        DISPftracks.push_back(new genfit::Track(fitTrack) );
    }
    delete fitter;

    return true;
}


//______________________________________________________________________________
Bool_t rAPPNUWSTTrackFit::Fit2TT(TObject *tmpTrack) {

//    std::cout<<"------------ Fit2TT ------------"<<std::endl;

    int fDebug=GetSP()->GetDebugLevel();//1;

    int trkid=0;
    TVector3 xyzhit0,momhit0;
    int nhits = 0;

    rAPPNUWSRecoTracksTT *aTrack = (rAPPNUWSRecoTracksTT *)tmpTrack;

    nhits = aTrack->Getnhits();
    if (nhits < 2) {
        if (fDebug>1) printf(" ****  !!! Event %lld not reconstructable: number of hits for TT signal track less than 2!\n",gAnalyzer->GetCurrentEventNumber());
        return false;
    }

    rAPPNUWSCSMTTHit *ahit0 = (rAPPNUWSCSMTTHit*) fBrHitsCSMTT->At(aTrack->GethitindexAt(0));
    xyzhit0=sclfac*TVector3(ahit0->GetfEntranceX(),ahit0->GetfEntranceY(),ahit0->GetfEntranceZ()); // mm -> cm
    momhit0=0.001*TVector3(ahit0->GetfEntranceMomX(),ahit0->GetfEntranceMomY(),ahit0->GetfEntranceMomZ()); // MeV -> GeV
    trkid=ahit0->GetfTrkIDofHit();


    //init values
    TVector3 xyz0=xyzhit0;//fVert;
    TVector3 pdir0=momhit0;
    pdir0.SetMag(1.);
    TVector3 pmom0=momhit0;//

    //Do initialization of initial covariance matrix with sigma_p,sigma_angle, 1cm position
    TMatrixDSym Cov(6); Cov.Zero();

    Cov[0][0] = Cov[1][1] =Cov[2][2] = sclfac*sclfac;//centimeters
    Cov[3][3] = Cov[4][4] =Cov[5][5] = 0.001*0.001;//GeV

    //-----------------------------------
    //init positron track with parameters from first State Vector and predefined Covariance matrix
    //-----------------------------------
    int pdgid=13;
    if(trkid<=fBrDataTrk->GetEntriesFast()&&trkid>0){
        for(int i=0;i<fBrDataTrk->GetEntriesFast();i++){
            rAPPNUWSGeantTrack* aMCTrack = ((rAPPNUWSGeantTrack*)fBrDataTrk->At(i));
            if(aMCTrack->GetfTrackID()==trkid){
                if (pdgid!=aMCTrack->GetfPDGCode()) {
                    pdgid=aMCTrack->GetfPDGCode();
                    if(fDebug) std::cout<<"Primary track n. "<<i<<" has different PDG "<<pdgid<<std::endl;
                    break;
                }
            }
        }
    }

    //
    if(fDebug)
        std::cout<<"set charge to pdgid ="<<pdgid<<std::endl;
    AbsTrackRep *rep = new RKTrackRep(pdgid);
    MeasuredStateOnPlane stateRef(rep);
    rep->setPosMomCov(stateRef,xyz0,pmom0,Cov);
    stateRef.setTime(0.);

    //init genfit track from initial state
    TVectorD seedState(6);
    TMatrixDSym seedCov(6);
    rep->get6DStateCov(stateRef, seedState, seedCov);
    Track fitTrack(rep,seedState, seedCov);
    fitTrack.setTimeSeed(0.);


    //-----------------------------------------------
    //fill hit information
    //-----------------------------------------------
    int nid=0;

//    //add vertex constrain
//    double sigmabeam=GetSP()->GetSigmaVtx();
//    if(sigmabeam>0){
//        TVectorD hitCoords(3);
//        TMatrixDSym hitCov(3);
//        for(int i=0;i<3;i++)
//            hitCoords(i)=gRandom->Gaus()*sigmabeam;
//        hitCov(0,0) = hitCov(1,1) = hitCov(2,2) = sigmabeam*sigmabeam;
//        genfit::SpacepointMeasurement* measurement = new genfit::SpacepointMeasurement(hitCoords, hitCov, 10, 100000, NULL);
//        fitTrack.insertMeasurement(measurement,nid++);
//        if(fDebug)
//            cout<<" add vertex constrain " <<hitCoords(0)<<" "<<hitCoords(1)<<" "<<hitCoords(2)<< " with +- "<<sigmabeam<<endl;
//    }

    int ihit0CSMTT=-1;
    int nhitsCSMTT=0;

    for(int ihit=0;ihit<nhits;ihit++){

//        rAPPNUWSRecoTracksTT *aTrack = (rAPPNUWSRecoTracksTT *)tmpTrack;
//        std::cout<<"Inserting hit i: "<<ihit<<" with n. "<<aTrack->GethitindexAt(ihit)<<std::endl;
        rAPPNUWSCSMTTHit *ahit =(rAPPNUWSCSMTTHit*) fBrHitsCSMTT->At(aTrack->GethitindexAt(ihit));
        addTThit (ahit, ihit, ihit0CSMTT, nhitsCSMTT, fitTrack/*, nid*/);

    }

    // ---- end of hit info filling ------------------------


    //  assert(fitTrack.checkConsistency());
    fitTrack.checkConsistency();
    genfit::FitStatus* fitStatus=fitTrack.getFitStatus(rep);
    if(fDebug){
        std::cout<<" init chi2 "<<fitStatus->getChi2()<<" nfailed "<<fitStatus->getNFailedPoints()
                     <<" P= "<<rep->getMomMag(stateRef)*rep->getCharge(stateRef)<<" +- "<<sqrt(rep->getMomVar(stateRef))
                     <<" nhits "<<nid<<" from "<<nhits/*<<" dch "<<nhitsdch*/<<" CSMTT "<<nhitsCSMTT<<std::endl;
        std::cout<<"init state ";xyz0.Print();std::cout<<" ";pmom0.Print();std::cout<<endl;
    }

    //choose different fitter
    genfit::AbsKalmanFitter* fitter = 0;
    switch(0/*GetSP()->GetKalmanType()*/){
    case 0:
        fitter=new DAF();
        break;
    case 1:
        fitter=new KalmanFitterRefTrack(20);
        break;
    case 2:
        fitter=new KalmanFitter(20);
        break;
    }
    /*
  if(GetSP()->GetKalmanType()>0){
    //use LR from patter recognition in case of usual KalmanFitter
    fitter->setMultipleMeasurementHandling(genfit::weightedClosestToPredictionWire);
  }*/

    if(fDebug>20){
        fitter->setDebugLvl(10);
        rep->setDebugLvl(10);
    }

    //-----------------------------------
    // FIT IT
    //-----------------------------------

    try{
        fitter->processTrack(&fitTrack);
    }catch(Exception& e){
        if(fDebug) std::cout<<"on fitting "<<e.what()<<std::endl;
    }
    fitStatus=fitTrack.getFitStatus(rep);
    bool fitstatus=fitStatus->isFitConverged()&&(fitStatus->getNFailedPoints()==0);
    if(fDebug) fitStatus->Print();


    TVector3 pos,mom;
    TMatrixDSym cov(6);
    TVector3 pos1,mom1;
    TMatrixDSym cov1(6);
    TVector3 pos2,mom2;
    TMatrixDSym cov2(6);
    double pmom=0;
    double tof=0;
    double sigmap=0.;

    //-----------------------------------
    // fill info from first hit
    //-----------------------------------

    try{
        const MeasuredStateOnPlane& stFirst=fitTrack.getFittedState();
        pmom=rep->getMomMag(stFirst)*rep->getCharge(stFirst);
        stFirst.getPosMomCov(pos,mom,cov);
        tof=stFirst.getTime();
    }catch(Exception& e){
        if(fDebug) std::cout<<"on getting state "<<e.what()<<std::endl;
    }


    if(fDebug)
        std::cout<<" chi2 "<<fitStatus->getChi2()<<" nfailed "<<fitStatus->getNFailedPoints()
        <<" P= "<<pmom<<" fitok="<<fitstatus<<std::endl;

    if(fDebug){std::cout<<"fitted xyz ";pos.Print();std::cout<<" mom ";mom.Print();std::cout<<endl;}

    //-----------------------------------
    //set states on hits
    //-----------------------------------

    unsigned int numhits = fitTrack.getNumPoints();

    int ngoodhits=0;
//    double sumddist=0;

    aTrack->SetStateVectorSize(nhits);
    aTrack->GetSkipped().resize(nhits,true);

    if(fitstatus){
        try{

            for(unsigned int jhit=0;jhit<numhits;jhit++){
                TrackPoint* point = fitTrack.getPoint(jhit);
                int ihit=point->getRawMeasurement(0)->getHitId();
                int idetid=point->getRawMeasurement(0)->getDetId();
                //skip virtual hit
                //        if(ihit>=1000) continue;

                //skip point without fitted information
                if(!point->hasFitterInfo(rep)) continue;

                KalmanFitterInfo* fi = static_cast<KalmanFitterInfo*>(point->getFitterInfo(rep));
                //get weights for LR combinations
                std::vector<double> dafWeights = fi->getWeights();

                //maximum weigth in fitting (from LR positions)
                int imaxdaf=std::distance(dafWeights.begin(),
                        std::max_element(dafWeights.begin(),dafWeights.end()));
                double maxdaf=dafWeights[imaxdaf];


                //fill histogram with final chi2 per hit
                const MeasurementOnPlane& residual = fi->getResidual(imaxdaf, false, false);
                const TVectorD& resid(residual.getState());

                //dont fill StateVector forr skipped hits during fitting(in normal case hit must have weight=1.)
                if(maxdaf<0.5) {
                    if(fDebug>9) std::cout<<"skip point "<<endl;
                    continue;
                }

                //fill biased best StateVector on hit
                // (averaged from forward-backward propagation)
                const MeasuredStateOnPlane& state=fi->getFittedState(true);
                state.getPosMomCov(pos,mom,cov);

//                //unbiased
//                const MeasuredStateOnPlane& state2=fi->getFittedState(false);
//                state2.getPosMomCov(pos2,mom2,cov2);

                /*if(idetid==0){
                    //average T0 shift over hits
                    sumddist+=resid(0)*(imaxdaf?1:-1);
                    ngoodhitsdch++;
                }else*/

                if(idetid<10){ //CSMTT or CSMBT hit
                    aTrack->SetSkippedAt(ihit,false);
                    *aTrack->GetStateVectorAt(ihit)=pos;
                    ngoodhits++;
                    if(IsHXresActive()) {
                        GetHXres()->Fill(resid(0));
                    }
                    if(IsHYresActive()) {
                        GetHYres()->Fill(resid(1));
                    }
//                    if(IsHZresActive()) {
//                        GetHYres()->Fill(resid(2));
//                    }
//                    rAPPNUWSCSMTTHit *ahit = (rAPPNUWSCSMTTHit*) fBrHitsCSMTT->At(aTrack->GethitindexAt(ihit));
                    if(fDebug>9) {
                        cout<<idetid<<" "<<ihit<<" track aver "<<state.getState()(3)<<" "<<state.getState()(4)<<" exact mes 0 0 dy,dz not biased "<<resid(0)<<" "<<resid(1)
                        <<" trk xyz ";pos.Print();std::cout<<" mom "<<mom.Y()<<endl;
                    }
                }
                // state.Print();
                // cov.Print();
                // state2.Print();
                // cov2.Print();
                if(ihit==aTrack->GethitindexAt(0))
                    if(IsHMomentumActive()) GetHMomentum()->Fill(pmom0.Mag(),mom.Mag()/pmom0.Mag()-1);
                if(fDebug>9) {
                    std::cout<<jhit<<" idetid "<<idetid<<" id "<<ihit<<" at hit ";pos.Print();std::cout<<" ";mom.Print();std::cout<<endl;
                }
            }
        }catch(Exception& e){
            if(fDebug) std::cout<<"on getting points "<<e.what()<<std::endl;
            fitstatus=false;
        }
//        sumddist/=ngoodhitsdch;
        if(fDebug) std::cout<<" filtrated hits "<<numhits-ngoodhits/*<<" average ddist "<<sumddist/(0.4/150e-9)*/<<std::endl;
    }


    //-----------------------------------
    //propagate to
    //-----------------------------------
    if(fitstatus){

        //force backward propagation(will be working forr only finite plane
        rep->setPropDir(-1);
        //take first fitted point
        TrackPoint* tp = fitTrack.getPointWithFitterInfo(0);
        if (tp == NULL) {std::cout << "Track has no TrackPoint with fitterInfo!(but fitstatus ok?)"<<std::endl;}
        KalmanFitterInfo* fi = static_cast<KalmanFitterInfo*>(tp->getFitterInfo(rep));
        MeasuredStateOnPlane state;

        //extrapolate to Upper face of the Top Tracker
        bool isUp=true;
        try{
            state=fi->getFittedState(true);
//            rep->extrapolateToLine(state,TVector3(0,fGeometry->GetCSMTtracker()->distOut()*sclfac,0),TVector3(0,0,1));

            rep->extrapolateToPlane ( state, genfit::SharedPlanePtrCreator::getPlanePtr(
                                                             new genfit::DetPlane(
                                                                   TVector3(0,fGeometry->GetCSMTtracker()->distOut()*sclfac,0),
                                                                   TVector3(0,1,0)
                                                             )
                                             )
                                     ,false
                                     ,true
                                    );

        }catch(Exception& e){
            if(fDebug) std::cout<<"on extrapolation to center line "<<e.what()<<std::endl;
            isUp=false;
        }
//        double tof_target=1e9;
        if(isUp){
//            tof_target=state.getTime();
            state.getPosMomCov(pos,mom,cov);
            double momrec=mom.Mag();
            sigmap=momrec*momrec*TMath::Sqrt(state.getCov()(0,0));

        }
        if(fDebug) {
            std::cout<<"vertex chi2 "<<fitStatus->getChi2()<<" ndf "<<fitStatus->getNdf()
            <<" nhits "<<nhits/*<<" dch "<<nhitsdch*/<<" CSMTT "<<nhitsCSMTT<<" nfailed "<<fitStatus->getNFailedPoints()
            <<" P= "<<mom.Mag()*rep->getCharge(state)<<" +- "<<sigmap<<" fitok="<<fitstatus
            <<" pos "; pos.Print();
            std::cout<<" mom "; mom.Print();
            //std::cout<<std::endl;
        }

        //extrapolate to Bottom face of the Top Tracker
        rep->setPropDir(1);
        bool isBt=true;
        try{
            state=fi->getFittedState(true);
//            rep->extrapolateToLine(state,TVector3(0,fGeometry->GetCSMTtracker()->distIn()*sclfac,0),TVector3(0,0,1));

            rep->extrapolateToPlane ( state, genfit::SharedPlanePtrCreator::getPlanePtr(
                                                             new genfit::DetPlane(
                                                                   TVector3(0,fGeometry->GetCSMTtracker()->distIn()*sclfac,0),
                                                                   TVector3(0,1,0)
                                                             )
                                             )
                                     ,false
                                     ,true
                                    );

        }catch(Exception& e){
            if(fDebug) std::cout<<"on extrapolation to center line "<<e.what()<<std::endl;
            isBt=false;
        }
//        double tof_target=1e9;
        if(isBt){
//            tof_target=state.getTime();
            state.getPosMomCov(pos1,mom1,cov1);
//            std::cout<<" pos1 "; pos1.Print();
//            std::cout<<" mom1 "; mom1.Print();
//            TVector3 tmpmom=mom1;
//            tmpmom.SetMag(1.0);
//            std::cout<<" dir1 "; tmpmom.Print();
        }

        //extrapolate to Upper face of the Bottom Tracker
        rep->setPropDir(1);
        bool isBT=true;
        try{
            state=fi->getFittedState(true);
//            rep->extrapolateToLine(state,TVector3(0,fGeometry->GetCSMBtracker()->distOut()*sclfac,0),TVector3(0,0,1));

            rep->extrapolateToPlane ( state, genfit::SharedPlanePtrCreator::getPlanePtr(
                                                             new genfit::DetPlane(
                                                                   TVector3(0,fGeometry->GetCSMBtracker()->distOut()*sclfac,0),
                                                                   TVector3(0,1,0)
                                                             )
                                             )
                                     ,false
                                     ,true
                                    );

        }catch(Exception& e){
            if(fDebug) std::cout<<"on extrapolation to center line "<<e.what()<<std::endl;
            isBT=false;
        }
//        double tof_target=1e9;
        if(isBT){
//            tof_target=state.getTime();
            state.getPosMomCov(pos2,mom2,cov2);
//            std::cout<<" pos2 "; pos2.Print();
//            std::cout<<" mom2 "; mom2.Print();
//            TVector3 tmpmom=mom2;
//            tmpmom.SetMag(1.0);
//            std::cout<<" dir2 "; tmpmom.Print();
        }

    }

//    aTrack->Setx0(pos.X()/sclfac);
//    aTrack->Seterr_x0(sqrt(cov(0,0))/sclfac);
//    aTrack->Sety0(pos.Y()/sclfac);
//    aTrack->Seterr_y0(sqrt(cov(1,1))/sclfac);
//    aTrack->Setz0(pos.Z()/sclfac);
//    aTrack->Seterr_z0(sqrt(cov(2,2))/sclfac);

    pos*=1.0/sclfac;
    aTrack->Setpos0(pos);
    for (int ic=0; ic<3; ++ic) { aTrack->SeterrPos0At(ic, sqrt(cov(ic,ic))/sclfac); }

    aTrack->Settheta(mom.Theta());
    aTrack->Seterr_theta(0.);
    aTrack->Setphi(mom.Phi());
    aTrack->Seterr_phi(0.);
    aTrack->SetMomentum(mom.Mag());
    aTrack->SetErr_Momentum(sigmap);
    aTrack->Setmom(mom);
//    aTrack->Setmom(ROOT::Math::XYZVector(mom.X(),mom.Y(),mom.Z()) );
    aTrack->Getcov()->ResizeTo(6,6);
    aTrack->Setcov(cov);

//    aTrack->Setx1(pos1.X()/sclfac);
//    aTrack->Seterr_x1(sqrt(cov1(0,0))/sclfac);
//    aTrack->Sety1(pos1.Y()/sclfac);
//    aTrack->Seterr_y1(sqrt(cov1(1,1))/sclfac);
//    aTrack->Setz1(pos1.Z()/sclfac);
//    aTrack->Seterr_z1(sqrt(cov1(2,2))/sclfac);

    pos1*=1.0/sclfac;
    aTrack->Setpos1(pos1);
    for (int ic=0; ic<3; ++ic) { aTrack->SeterrPos1At(ic, sqrt(cov1(ic,ic))/sclfac); }
    aTrack->Settheta1(mom1.Theta());
    aTrack->Seterr_theta1(0.);
    aTrack->Setphi1(mom1.Phi());
    aTrack->Seterr_phi1(0.);

//    aTrack->Setx2(pos2.X()/sclfac);
//    aTrack->Seterr_x2(sqrt(cov2(0,0))/sclfac);
//    aTrack->Sety2(pos2.Y()/sclfac);
//    aTrack->Seterr_y2(sqrt(cov2(1,1))/sclfac);
//    aTrack->Setz2(pos2.Z()/sclfac);
//    aTrack->Seterr_z2(sqrt(cov2(2,2))/sclfac);

    pos2*=1.0/sclfac;
    aTrack->Setpos2(pos2);
    for (int ic=0; ic<3; ++ic) { aTrack->SeterrPos2At(ic, sqrt(cov2(ic,ic))/sclfac); }
    aTrack->Settheta2(mom2.Theta());
    aTrack->Seterr_theta2(0.);
    aTrack->Setphi2(mom2.Phi());
    aTrack->Seterr_phi2(0.);

    //fill final information
    aTrack->Setnhits(nhits);//nhitsCSMTT
    aTrack->Setngoodhits(ngoodhits);
    aTrack->Setchi2(fitStatus->getChi2());
    aTrack->Setdof(fitStatus->getNdf());
    aTrack->SetIsFitted(fitstatus);

    TTftracks.push_back(new genfit::Track(fitTrack) );
    if ( GetSP()->GetDoDisplay() ) {
        DISPftracks.push_back(new genfit::Track(fitTrack) );
    }
    delete fitter;

    return true;
}

//______________________________________________________________________________
Bool_t rAPPNUWSTTrackFit::Fit2BT(TObject *tmpTrack) {

//    std::cout<<"------------ Fit2BT ------------"<<std::endl;

    int fDebug=GetSP()->GetDebugLevel();//1;

    int trkid=0;
    TVector3 xyzhit0,momhit0;
    int nhits = 0;

    rAPPNUWSRecoTracksBT *aTrack = (rAPPNUWSRecoTracksBT *)tmpTrack;

    nhits = aTrack->Getnhits();
    if (nhits < 2) {
        if (fDebug>1) printf(" ****  !!! Event %lld not reconstructable: number of hits for BT signal track less than 2!\n",gAnalyzer->GetCurrentEventNumber());
        return false;
    }

    rAPPNUWSCSMBTHit *ahit0 = (rAPPNUWSCSMBTHit*) fBrHitsCSMBT->At(aTrack->GethitindexAt(0));
    xyzhit0=sclfac*TVector3(ahit0->GetfEntranceX(),ahit0->GetfEntranceY(),ahit0->GetfEntranceZ()); // mm -> cm
    momhit0=0.001*TVector3(ahit0->GetfEntranceMomX(),ahit0->GetfEntranceMomY(),ahit0->GetfEntranceMomZ()); // MeV -> GeV
    trkid=ahit0->GetfTrkIDofHit();


    //init values
    TVector3 xyz0=xyzhit0;//fVert;
    TVector3 pdir0=momhit0;
    pdir0.SetMag(1.);
    TVector3 pmom0=momhit0;//

    //Do initialization of initial covariance matrix with sigma_p,sigma_angle, 1cm position
    TMatrixDSym Cov(6); Cov.Zero();

    Cov[0][0] = Cov[1][1] =Cov[2][2] = sclfac*sclfac;//centimeters
    Cov[3][3] = Cov[4][4] =Cov[5][5] = 0.001*0.001;//GeV

    //-----------------------------------
    //init positron track with parameters from first State Vector and predefined Covariance matrix
    //-----------------------------------
    int pdgid=13;
    if(trkid<=fBrDataTrk->GetEntriesFast()&&trkid>0){
        for(int i=0;i<fBrDataTrk->GetEntriesFast();i++){
            rAPPNUWSGeantTrack* aMCTrack = ((rAPPNUWSGeantTrack*)fBrDataTrk->At(i));
            if(aMCTrack->GetfTrackID()==trkid){
                if (pdgid!=aMCTrack->GetfPDGCode()) {
                    pdgid=aMCTrack->GetfPDGCode();
                    if(fDebug) std::cout<<"Primary track n. "<<i<<" has different PDG "<<pdgid<<std::endl;
                    break;
                }
            }
        }
    }

    //
    if(fDebug)
        std::cout<<"set charge to pdgid ="<<pdgid<<std::endl;
    AbsTrackRep *rep = new RKTrackRep(pdgid);
    MeasuredStateOnPlane stateRef(rep);
    rep->setPosMomCov(stateRef,xyz0,pmom0,Cov);
    stateRef.setTime(0.);

    //init genfit track from initial state
    TVectorD seedState(6);
    TMatrixDSym seedCov(6);
    rep->get6DStateCov(stateRef, seedState, seedCov);
    Track fitTrack(rep,seedState, seedCov);
    fitTrack.setTimeSeed(0.);


    //-----------------------------------------------
    //fill hit information
    //-----------------------------------------------
    int nid=0;

//    //add vertex constrain
//    double sigmabeam=GetSP()->GetSigmaVtx();
//    if(sigmabeam>0){
//        TVectorD hitCoords(3);
//        TMatrixDSym hitCov(3);
//        for(int i=0;i<3;i++)
//            hitCoords(i)=gRandom->Gaus()*sigmabeam;
//        hitCov(0,0) = hitCov(1,1) = hitCov(2,2) = sigmabeam*sigmabeam;
//        genfit::SpacepointMeasurement* measurement = new genfit::SpacepointMeasurement(hitCoords, hitCov, 10, 100000, NULL);
//        fitTrack.insertMeasurement(measurement,nid++);
//        if(fDebug)
//            cout<<" add vertex constrain " <<hitCoords(0)<<" "<<hitCoords(1)<<" "<<hitCoords(2)<< " with +- "<<sigmabeam<<endl;
//    }

    int ihit0CSMBT=-1;
    int nhitsCSMBT=0;

    for(int ihit=0;ihit<nhits;ihit++){

//        rAPPNUWSRecoTracksBT *aTrack = (rAPPNUWSRecoTracksBT *)tmpTrack;
//        std::cout<<"Inserting hit i: "<<ihit<<" with n. "<<aTrack->GethitindexAt(ihit)<<std::endl;
        rAPPNUWSCSMBTHit *ahit =(rAPPNUWSCSMBTHit*) fBrHitsCSMBT->At(aTrack->GethitindexAt(ihit));
        addBThit (ahit, ihit, ihit0CSMBT, nhitsCSMBT, fitTrack/*, nid*/);

    }

    // ---- end of hit info filling ------------------------


    //  assert(fitTrack.checkConsistency());
    fitTrack.checkConsistency();
    genfit::FitStatus* fitStatus=fitTrack.getFitStatus(rep);
    if(fDebug){
        std::cout<<" init chi2 "<<fitStatus->getChi2()<<" nfailed "<<fitStatus->getNFailedPoints()
                     <<" P= "<<rep->getMomMag(stateRef)*rep->getCharge(stateRef)<<" +- "<<sqrt(rep->getMomVar(stateRef))
                     <<" nhits "<<nid<<" from "<<nhits/*<<" dch "<<nhitsdch*/<<" CSMBT "<<nhitsCSMBT<<std::endl;
        std::cout<<"init state ";xyz0.Print();std::cout<<" ";pmom0.Print();std::cout<<endl;
    }

    //choose different fitter
    genfit::AbsKalmanFitter* fitter = 0;
    switch(0/*GetSP()->GetKalmanType()*/){
    case 0:
        fitter=new DAF();
        break;
    case 1:
        fitter=new KalmanFitterRefTrack(20);
        break;
    case 2:
        fitter=new KalmanFitter(20);
        break;
    }
    /*
  if(GetSP()->GetKalmanType()>0){
    //use LR from patter recognition in case of usual KalmanFitter
    fitter->setMultipleMeasurementHandling(genfit::weightedClosestToPredictionWire);
  }*/

    if(fDebug>20){
        fitter->setDebugLvl(10);
        rep->setDebugLvl(10);
    }

    //-----------------------------------
    // FIT IT
    //-----------------------------------

    try{
        fitter->processTrack(&fitTrack);
    }catch(Exception& e){
        if(fDebug) std::cout<<"on fitting "<<e.what()<<std::endl;
    }
    fitStatus=fitTrack.getFitStatus(rep);
    bool fitstatus=fitStatus->isFitConverged()&&(fitStatus->getNFailedPoints()==0);
    if(fDebug) fitStatus->Print();

    bool fndpos=false;
    TVector3 pos,mom;
    TMatrixDSym cov(6);
    bool fndpos1=false;
    TVector3 pos1,mom1;
    TMatrixDSym cov1(6);
    bool fndpos2=false;
    TVector3 pos2,mom2;
    TMatrixDSym cov2(6);
    bool fndposCnt=false;
    TVector3 posCnt,momCnt;
    TMatrixDSym covCnt(6);
//    TVector3 posCnt1;
    double pmom=0;
    double tof=0;
    double sigmap=0.;

    //-----------------------------------
    // fill info from first hit
    //-----------------------------------

    try{
        const MeasuredStateOnPlane& stFirst=fitTrack.getFittedState();
        pmom=rep->getMomMag(stFirst)*rep->getCharge(stFirst);
        stFirst.getPosMomCov(pos,mom,cov);
        tof=stFirst.getTime();
    }catch(Exception& e){
        if(fDebug) std::cout<<"on getting state "<<e.what()<<std::endl;
    }


    if(fDebug)
        std::cout<<" chi2 "<<fitStatus->getChi2()<<" nfailed "<<fitStatus->getNFailedPoints()
        <<" P= "<<pmom<<" fitok="<<fitstatus<<std::endl;

    if(fDebug){std::cout<<"fitted xyz ";pos.Print();std::cout<<" mom ";mom.Print();std::cout<<endl;}

    //-----------------------------------
    //set states on hits
    //-----------------------------------

    unsigned int numhits = fitTrack.getNumPoints();

    int ngoodhits=0;
//    double sumddist=0;

    aTrack->SetStateVectorSize(nhits);
    aTrack->GetSkipped().resize(nhits,true);

    if(fitstatus){
        try{

            for(unsigned int jhit=0;jhit<numhits;jhit++){
                TrackPoint* point = fitTrack.getPoint(jhit);
                int ihit=point->getRawMeasurement(0)->getHitId();
                int idetid=point->getRawMeasurement(0)->getDetId();
                //skip virtual hit
                //        if(ihit>=1000) continue;

                //skip point without fitted information
                if(!point->hasFitterInfo(rep)) continue;

                KalmanFitterInfo* fi = static_cast<KalmanFitterInfo*>(point->getFitterInfo(rep));
                //get weights for LR combinations
                std::vector<double> dafWeights = fi->getWeights();

                //maximum weigth in fitting (from LR positions)
                int imaxdaf=std::distance(dafWeights.begin(),
                        std::max_element(dafWeights.begin(),dafWeights.end()));
                double maxdaf=dafWeights[imaxdaf];


                //fill histogram with final chi2 per hit
                const MeasurementOnPlane& residual = fi->getResidual(imaxdaf, false, false);
                const TVectorD& resid(residual.getState());

                //dont fill StateVector forr skipped hits during fitting(in normal case hit must have weight=1.)
                if(maxdaf<0.5) {
                    if(fDebug>9) std::cout<<"skip point "<<endl;
                    continue;
                }

                //fill biased best StateVector on hit
                // (averaged from forward-backward propagation)
                const MeasuredStateOnPlane& state=fi->getFittedState(true);
                state.getPosMomCov(pos,mom,cov);

//                //unbiased
//                const MeasuredStateOnPlane& state2=fi->getFittedState(false);
//                state2.getPosMomCov(pos2,mom2,cov2);

                /*if(idetid==0){
                    //average T0 shift over hits
                    sumddist+=resid(0)*(imaxdaf?1:-1);
                    ngoodhitsdch++;
                }else*/

                if(idetid<10){ //CSMTT or CSMBT hit
                    aTrack->SetSkippedAt(ihit,false);
                    *aTrack->GetStateVectorAt(ihit)=pos;
                    ngoodhits++;
                    if(IsHXresActive()) {
                        GetHXres()->Fill(resid(0));
                    }
                    if(IsHYresActive()) {
                        GetHYres()->Fill(resid(1));
                    }
//                    if(IsHZresActive()) {
//                        GetHYres()->Fill(resid(2));
//                    }
//                    rAPPNUWSCSMBTHit *ahit = (rAPPNUWSCSMBTHit*) fBrHitsCSMBT->At(aTrack->GethitindexAt(ihit));
                    if(fDebug>9) {
                        cout<<idetid<<" "<<ihit<<" track aver "<<state.getState()(3)<<" "<<state.getState()(4)<<" exact mes 0 0 dy,dz not biased "<<resid(0)<<" "<<resid(1)
                        <<" trk xyz ";pos.Print();std::cout<<" mom "<<mom.Y()<<endl;
                    }
                }
                // state.Print();
                // cov.Print();
                // state2.Print();
                // cov2.Print();
                if(ihit==aTrack->GethitindexAt(0))
                    if(IsHMomentumActive()) GetHMomentum()->Fill(pmom0.Mag(),mom.Mag()/pmom0.Mag()-1);
                if(fDebug>9) {
                    std::cout<<jhit<<" idetid "<<idetid<<" id "<<ihit<<" at hit ";pos.Print();std::cout<<" ";mom.Print();std::cout<<endl;
                }
            }
        }catch(Exception& e){
            if(fDebug) std::cout<<"on getting points "<<e.what()<<std::endl;
            fitstatus=false;
        }
//        sumddist/=ngoodhitsdch;
        if(fDebug) std::cout<<" filtrated hits "<<numhits-ngoodhits/*<<" average ddist "<<sumddist/(0.4/150e-9)*/<<std::endl;
    }


    //-----------------------------------
    //propagate to
    //-----------------------------------
    if(fitstatus){

        //force backward propagation(will be working forr only finite plane
        rep->setPropDir(-1);
        //take first fitted point
        TrackPoint* tp = fitTrack.getPointWithFitterInfo(0);
        if (tp == NULL) {std::cout << "Track has no TrackPoint with fitterInfo!(but fitstatus ok?)"<<std::endl;}
        KalmanFitterInfo* fi = static_cast<KalmanFitterInfo*>(tp->getFitterInfo(rep));
        MeasuredStateOnPlane state;

        //extrapolate to Upper face of the Bottom Tracker
        bool isUp=true;
        try{
            state=fi->getFittedState(true);
//            rep->extrapolateToLine(state,TVector3(0,fGeometry->GetCSMBtracker()->distOut()*sclfac,0),TVector3(0,0,1));

            rep->extrapolateToPlane ( state, genfit::SharedPlanePtrCreator::getPlanePtr(
                                                             new genfit::DetPlane(
                                                                   TVector3(0,fGeometry->GetCSMBtracker()->distOut()*sclfac,0),
                                                                   TVector3(0,1,0)
                                                             )
                                             )
                                     ,false
                                     ,true
                                    );

        }catch(Exception& e){
            if(fDebug) std::cout<<" on extrapolation of BT track to Upper face of the Bottom Tracker "<<e.what()<<std::endl;
            isUp=false;
        }
//        double tof_target=1e9;
        if(isUp){
            fndpos=true;
//            tof_target=state.getTime();
            state.getPosMomCov(pos,mom,cov);
            double momrec=mom.Mag();
            sigmap=momrec*momrec*TMath::Sqrt(state.getCov()(0,0));

        }
        if(fDebug) {
            std::cout<<"vertex chi2 "<<fitStatus->getChi2()<<" ndf "<<fitStatus->getNdf()
            <<" nhits "<<nhits/*<<" dch "<<nhitsdch*/<<" CSMBT "<<nhitsCSMBT<<" nfailed "<<fitStatus->getNFailedPoints()
            <<" P= "<<mom.Mag()*rep->getCharge(state)<<" +- "<<sigmap<<" fitok="<<fitstatus
            <<" pos "; pos.Print();
            std::cout<<" mom "; mom.Print();
            //std::cout<<std::endl;
        }

        //extrapolate to Bottom face of the Bottom Tracker
        rep->setPropDir(1);
        bool isBt=true;
        try{
            state=fi->getFittedState(true);
//            rep->extrapolateToLine(state,TVector3(0,fGeometry->GetCSMBtracker()->distIn()*sclfac,0),TVector3(0,0,1));

            rep->extrapolateToPlane ( state, genfit::SharedPlanePtrCreator::getPlanePtr(
                                                             new genfit::DetPlane(
                                                                   TVector3(0,fGeometry->GetCSMBtracker()->distIn()*sclfac,0),
                                                                   TVector3(0,1,0)
                                                             )
                                             )
                                     ,false
                                     ,true
                                    );

        }catch(Exception& e){
            if(fDebug) std::cout<<"on extrapolation of BT track to Bottom face of the Bottom Tracker "<<e.what()<<std::endl;
            isBt=false;
        }
//        double tof_target=1e9;
        if(isBt){
            fndpos1=true;
//            tof_target=state.getTime();
            state.getPosMomCov(pos1,mom1,cov1);
//            std::cout<<" pos1 "; pos1.Print();
//            std::cout<<" mom1 "; mom1.Print();
//            TVector3 tmpmom=mom1;
//            tmpmom.SetMag(1.0);
//            std::cout<<" dir1 "; tmpmom.Print();
       }

        //extrapolate to Bottom face of the Top Tracker
        rep->setPropDir(-1);
        bool isTT=true;
        try{
            state=fi->getFittedState(true);
//            rep->extrapolateToLine(state,TVector3(0,fGeometry->GetCSMTtracker()->distIn()*sclfac,0),TVector3(0,0,1));

            rep->extrapolateToPlane ( state, genfit::SharedPlanePtrCreator::getPlanePtr(
                                                             new genfit::DetPlane(
                                                                   TVector3(0,fGeometry->GetCSMTtracker()->distIn()*sclfac,0),
                                                                   TVector3(0,1,0)
                                                             )
                                             )
                                     ,false
                                     ,true
                                    );

        }catch(Exception& e){
            if(fDebug) std::cout<<"on extrapolation of BT track to Bottom face of the Top Tracker "<<e.what()<<std::endl;
            isTT=false;
        }
//        double tof_target=1e9;
        if(isTT){
            fndpos2=true;
//            tof_target=state.getTime();
            state.getPosMomCov(pos2,mom2,cov2);
//            std::cout<<" pos2 "; pos2.Print();
//            std::cout<<" mom2 "; mom2.Print();
//            TVector3 tmpmom=mom2;
//            tmpmom.SetMag(1.0);
//            std::cout<<" dir2 "; tmpmom.Print();
        }

        //extrapolate to the center of the tomographer (y)
        rep->setPropDir(-1);
        bool isCnt=true;
        try{
            state=fi->getFittedState(true);
//            rep->extrapolateToLine(state,TVector3(0,fGeometry->GetCSMTtracker()->distIn()*sclfac,0),TVector3(0,0,1));

            rep->extrapolateToPlane ( state, genfit::SharedPlanePtrCreator::getPlanePtr(
                                                             new genfit::DetPlane(
                                                                   TVector3(0,tomgCent,0),
                                                                   TVector3(0,1,0)
                                                             )
                                             )
                                     ,false
                                     ,true
                                    );

        }catch(Exception& e){
            if(fDebug) std::cout<<"on extrapolation of BT track to the center of the tomographer (y) "<<e.what()<<std::endl;
            isCnt=false;
        }
//        double tof_target=1e9;
        if(isCnt){
            fndposCnt=true;
//            tof_target=state.getTime();
            state.getPosMomCov(posCnt,momCnt,covCnt);
//            std::cout<<" posCnt "; posCnt.Print();
//            std::cout<<" momCnt "; momCnt.Print();
//            TVector3 tmpmom=momCnt;
//            tmpmom.SetMag(1.0);
//            std::cout<<" dirCnt "; tmpmom.Print();

//            // Extrapolation test
//            TVector3 tmpdir, yax(0,-1,0);
//            tmpdir.SetMagThetaPhi( 1.0, mom.Theta(), mom.Phi() );
//            double distY = 300 - pos.Y();
//            double dist = distY/TMath::Cos(TMath::Abs(tmpdir.Angle(yax)));
//            posCnt1 = pos-dist*tmpdir;

//            std::cout<<"------------------------ state cov ------------------------"<<std::endl;
//            state.getCov().Print();
//            std::cout<<"------------------------ posmom cov ------------------------"<<std::endl;
//            posCnt.Print();
//            momCnt.Print();
//            covCnt.Print();
//            std::cout<<"------------------------ 6D state cov ------------------------"<<std::endl;
//            TVectorD tmpStateVec;
//            TMatrixDSym tmpCov;
//            state.get6DStateCov(tmpStateVec, tmpCov);
//            tmpStateVec.Print();
//            tmpCov.Print();

        }
    }

    if (fndpos) {
        //    aTrack->Setx0(pos.X()/sclfac);
        //    aTrack->Seterr_x0(sqrt(cov(0,0))/sclfac);
        //    aTrack->Sety0(pos.Y()/sclfac);
        //    aTrack->Seterr_y0(sqrt(cov(1,1))/sclfac);
        //    aTrack->Setz0(pos.Z()/sclfac);
        //    aTrack->Seterr_z0(sqrt(cov(2,2))/sclfac);

        pos*=1.0/sclfac;
        aTrack->Setpos0(pos);
        for (int ic=0; ic<3; ++ic) { aTrack->SeterrPos0At(ic, sqrt(cov(ic,ic))/sclfac); }

        aTrack->Settheta(mom.Theta());
        aTrack->Seterr_theta(0.);
        aTrack->Setphi(mom.Phi());
        aTrack->Seterr_phi(0.);
        aTrack->SetMomentum(mom.Mag());
        aTrack->SetErr_Momentum(sigmap);
        aTrack->Setmom(mom);
        //    aTrack->Setmom(ROOT::Math::XYZVector(mom.X(),mom.Y(),mom.Z()) );
        aTrack->Getcov()->ResizeTo(6,6);
        aTrack->Setcov(cov);
    }

    if (fndpos1) {
        pos1*=1.0/sclfac;
        aTrack->Setpos1(pos1);
        for (int ic=0; ic<3; ++ic) { aTrack->SeterrPos1At(ic, sqrt(cov1(ic,ic))/sclfac); }
        aTrack->Settheta1(mom1.Theta());
        aTrack->Seterr_theta1(0.);
        aTrack->Setphi1(mom1.Phi());
        aTrack->Seterr_phi1(0.);
    }

    if (fndpos2) {
        pos2*=1.0/sclfac;
        aTrack->Setpos2(pos2);
        for (int ic=0; ic<3; ++ic) { aTrack->SeterrPos2At(ic, sqrt(cov2(ic,ic))/sclfac); }
        aTrack->Settheta2(mom2.Theta());
        aTrack->Seterr_theta2(0.);
        aTrack->Setphi2(mom2.Phi());
        aTrack->Seterr_phi2(0.);
    }

    if (fndposCnt) {
        posCnt*=1.0/sclfac;
        aTrack->SetposCnt(posCnt);
        for (int ic=0; ic<3; ++ic) { aTrack->SeterrPosCntAt(ic, sqrt(covCnt(ic,ic))/sclfac); }
        aTrack->SetthetaCnt(momCnt.Theta());
        aTrack->Seterr_thetaCnt(sgmTheta1(momCnt, covCnt));
        aTrack->SetphiCnt(momCnt.Phi());
        aTrack->Seterr_phiCnt(sgmPhi(momCnt, covCnt));

//        posCnt1*=1.0/sclfac;
//        aTrack->SetposCnt1(posCnt1);
    }

    //fill final information
    aTrack->Setnhits(nhits);//nhitsCSMBT
    aTrack->Setngoodhits(ngoodhits);
    aTrack->Setchi2(fitStatus->getChi2());
    aTrack->Setdof(fitStatus->getNdf());
    aTrack->SetIsFitted(fitstatus);

    BTftracks.push_back(new genfit::Track(fitTrack));
    if ( GetSP()->GetDoDisplay() ) {
        DISPftracks.push_back(new genfit::Track(fitTrack));
    }

    delete fitter;

    return true;
}

//______________________________________________________________________________
void rAPPNUWSTTrackFit::addTThit (rAPPNUWSCSMTTHit *ahit, int &ihit, int &ihit0, int &nhits, Track &fitTrack/*, int &nid*/) {
    int fDebug=GetSP()->GetDebugLevel();//1;

//    rAPPNUWSRecoTracksTT *aTrack = (rAPPNUWSRecoTracksTT *)tmpTrack;

    if(ihit0<0) ihit0=0;
    nhits++;
//    rAPPNUWSCSMTTHit *ahit =(rAPPNUWSCSMTTHit*) fBrHitsCSMTT->At(aTrack->GethitindexAt(ihit));

    unsigned long nRO = ahit->GetfChanId();
    fGeometry->GetCSMTTROChanHandle()->SelectRODet(nRO);
    bool isFw = fGeometry->GetCSMTTROChanHandle()->isFwLayer();

    double pxlResolution=round(fGeometry->GetCSMTTROChanHandle()->GetROChanFstSdPitch()*2886.751345948)*1e-4*sclfac;  //1e+4*1/sqrt(12)=2886.751345948 (1e+4 to round at the um level), 1e-4*0.1 for mm -> cm
    double pxlResolutionSndSd=round(fGeometry->GetCSMTTROChanHandle()->GetROChanSndSdPitch()*2886.751345948)*1e-4*sclfac;
    TMatrixDSym hitpxlCov(2);
    hitpxlCov.UnitMatrix();
    hitpxlCov *= pxlResolution*pxlResolutionSndSd;

    const CLHEP::Hep3Vector& lclmid   = fGeometry->GetCSMTTROChanHandle()->GetROChanCenterLcl();

    TVectorD hitCoords(2);
    hitCoords[0] = sclfac*lclmid.x();
    hitCoords[1] = sclfac*lclmid.z();
    genfit::PlanarMeasurement* measurement = new genfit::PlanarMeasurement(hitCoords, hitpxlCov, 0, ihit, nullptr);

    const CLHEP::Hep3Vector& ldmid   = fGeometry->GetCSMTTROChanHandle()->GetROLayerMidPoint();
    const CLHEP::Hep3Vector& ldFstSdDir   = fGeometry->GetCSMTTROChanHandle()->GetLadderFstSdDir();
    const CLHEP::Hep3Vector& ldSndSdDir   = fGeometry->GetCSMTTROChanHandle()->GetLadderSndSdDir();
    TVector3 ldMid(sclfac*ldmid.x(),sclfac*ldmid.y(),sclfac*ldmid.z());
    TVector3 udir(ldFstSdDir.x(),ldFstSdDir.y(),ldFstSdDir.z());
    TVector3 vdir(ldSndSdDir.x(),ldSndSdDir.y(),ldSndSdDir.z());

    measurement->setPlane(genfit::SharedPlanePtr(new genfit::DetPlane(ldMid, udir, vdir)), 0);//++nid);
    fitTrack.insertMeasurement(measurement);//,++nid);
    if(fDebug>1) {
        const CLHEP::Hep3Vector& glbmid = fGeometry->GetCSMTTROChanHandle()->GetROChanCenterGbl();
        TVector3 pixel(sclfac*glbmid.x(),sclfac*glbmid.y(),sclfac*glbmid.z());
        TVector3 hitPnt(sclfac*ahit->GetfEntranceX(),sclfac*ahit->GetfEntranceY(),sclfac*ahit->GetfEntranceZ());
        TVector3 pixelM(ldMid.x()+hitCoords[0]*udir.x()+hitCoords[1]*vdir.x(),
                ldMid.y()+hitCoords[0]*udir.y()+hitCoords[1]*vdir.y(),
                ldMid.z()+hitCoords[0]*udir.z()+hitCoords[1]*vdir.z());
        cout<<std::endl<<" add "<<ihit<<" CSMTT mes in Sec "<< fGeometry->GetCSMTTROChanHandle()->GetPhiSecId()
                                      <<" nRO "<< nRO
                                      <<" lay "<< fGeometry->GetCSMTTROChanHandle()->GetLayerId()
                                      <<" lad "<< fGeometry->GetCSMTTROChanHandle()->GetLadderId()
                                      <<" is Fw "<<isFw
                                      <<" pos: "<<hitCoords[0]<<" "<<hitCoords[1]<<endl;
        cout<<" xyz "<<hitPnt.X()<<" "<<hitPnt.Y()<<" "<<hitPnt.Z()<< " with +- "<<pxlResolution<< " with +- "<<pxlResolutionSndSd<<" T "<<ahit->GetfGlobalTime()<<endl;

        cout<<"  M  "<<pixelM.X()<<" "<<pixelM.Y()<<" "<<pixelM.Z()<<" dist on Plane "<<sqrt(pow((pixelM-hitPnt).Dot(udir),2)+pow((pixelM-hitPnt).Dot(vdir),2))<<" dist "<<(pixelM-hitPnt).Mag()<<endl;
        cout<<"  P  "<<pixel.X()<<" "<<pixel.Y()<<" "<<pixel.Z()<<" dist on Plane "<<sqrt(pow((pixel-hitPnt).Dot(udir),2)+pow((pixel-hitPnt).Dot(vdir),2))<<" dist "<<(pixel-hitPnt).Mag()<<endl;

        cout<<"Ld mid: "; ldMid.Print();
        cout<<"U dir: "; udir.Print();
        cout<<"V dir: "; vdir.Print();
        cout<<std::endl;
    }

}

//______________________________________________________________________________
void rAPPNUWSTTrackFit::addBThit (rAPPNUWSCSMBTHit *ahit, int &ihit, int &ihit0, int &nhits, Track &fitTrack/*, int &nid*/) {
    int fDebug=GetSP()->GetDebugLevel();//1;

//    rAPPNUWSRecoTracksBT *aTrack = (rAPPNUWSRecoTracksBT *)tmpTrack;

    if(ihit0<0) ihit0=0;
    nhits++;
//    rAPPNUWSCSMBTHit *ahit =(rAPPNUWSCSMBTHit*) fBrHitsCSMBT->At(aTrack->GethitindexAt(ihit));

    unsigned long nRO = ahit->GetfChanId();
    fGeometry->GetCSMBTROChanHandle()->SelectRODet(nRO);
    bool isFw = fGeometry->GetCSMBTROChanHandle()->isFwLayer();

    double pxlResolution=round(fGeometry->GetCSMBTROChanHandle()->GetROChanFstSdPitch()*2886.751345948)*1e-4*sclfac;  //1e+4*1/sqrt(12)=2886.751345948 (1e+4 to round at the um level), 1e-4*0.1 for mm -> cm
    double pxlResolutionSndSd=round(fGeometry->GetCSMBTROChanHandle()->GetROChanSndSdPitch()*2886.751345948)*1e-4*sclfac;
    TMatrixDSym hitpxlCov(2);
    hitpxlCov.UnitMatrix();
    hitpxlCov *= pxlResolution*pxlResolutionSndSd;

    const CLHEP::Hep3Vector& lclmid   = fGeometry->GetCSMBTROChanHandle()->GetROChanCenterLcl();

    TVectorD hitCoords(2);
    hitCoords[0] = sclfac*lclmid.x();
    hitCoords[1] = sclfac*lclmid.z();
    genfit::PlanarMeasurement* measurement = new genfit::PlanarMeasurement(hitCoords, hitpxlCov, 1, ihit, nullptr);

    const CLHEP::Hep3Vector& ldmid   = fGeometry->GetCSMBTROChanHandle()->GetROLayerMidPoint();
    const CLHEP::Hep3Vector& ldFstSdDir   = fGeometry->GetCSMBTROChanHandle()->GetLadderFstSdDir();
    const CLHEP::Hep3Vector& ldSndSdDir   = fGeometry->GetCSMBTROChanHandle()->GetLadderSndSdDir();
    TVector3 ldMid(sclfac*ldmid.x(),sclfac*ldmid.y(),sclfac*ldmid.z());
    TVector3 udir(ldFstSdDir.x(),ldFstSdDir.y(),ldFstSdDir.z());
    TVector3 vdir(ldSndSdDir.x(),ldSndSdDir.y(),ldSndSdDir.z());

    measurement->setPlane(genfit::SharedPlanePtr(new genfit::DetPlane(ldMid, udir, vdir)), 0);//++nid);
    fitTrack.insertMeasurement(measurement);//,++nid);
    if(fDebug>1) {
        const CLHEP::Hep3Vector& glbmid = fGeometry->GetCSMBTROChanHandle()->GetROChanCenterGbl();
        TVector3 pixel(sclfac*glbmid.x(),sclfac*glbmid.y(),sclfac*glbmid.z());
        TVector3 hitPnt(sclfac*ahit->GetfEntranceX(),sclfac*ahit->GetfEntranceY(),sclfac*ahit->GetfEntranceZ());
        TVector3 pixelM(ldMid.x()+hitCoords[0]*udir.x()+hitCoords[1]*vdir.x(),
                ldMid.y()+hitCoords[0]*udir.y()+hitCoords[1]*vdir.y(),
                ldMid.z()+hitCoords[0]*udir.z()+hitCoords[1]*vdir.z());
        cout<<std::endl<<" add "<<ihit<<" CSMBT mes in Sec "<< fGeometry->GetCSMBTROChanHandle()->GetPhiSecId()
                                      <<" nRO "<< nRO
                                      <<" lay "<< fGeometry->GetCSMBTROChanHandle()->GetLayerId()
                                      <<" lad "<< fGeometry->GetCSMBTROChanHandle()->GetLadderId()
                                      <<" is Fw "<<isFw
                                      <<" pos: "<<hitCoords[0]<<" "<<hitCoords[1]<<endl;
        cout<<" xyz "<<hitPnt.X()<<" "<<hitPnt.Y()<<" "<<hitPnt.Z()<< " with +- "<<pxlResolution<< " with +- "<<pxlResolutionSndSd<<" T "<<ahit->GetfGlobalTime()<<endl;

        cout<<"  M  "<<pixelM.X()<<" "<<pixelM.Y()<<" "<<pixelM.Z()<<" dist on Plane "<<sqrt(pow((pixelM-hitPnt).Dot(udir),2)+pow((pixelM-hitPnt).Dot(vdir),2))<<" dist "<<(pixelM-hitPnt).Mag()<<endl;
        cout<<"  P  "<<pixel.X()<<" "<<pixel.Y()<<" "<<pixel.Z()<<" dist on Plane "<<sqrt(pow((pixel-hitPnt).Dot(udir),2)+pow((pixel-hitPnt).Dot(vdir),2))<<" dist "<<(pixel-hitPnt).Mag()<<endl;

        cout<<"Ld mid: "; ldMid.Print();
        cout<<"U dir: "; udir.Print();
        cout<<"V dir: "; vdir.Print();
        cout<<std::endl;
    }


}

void rAPPNUWSTTrackFit::FindScatter() {

//    printf("\n rAPPNUWSTTrackFit::FindScatter ***** event %lld ************************ \n",gAnalyzer->GetCurrentEventNumber());

    std::map<int,int> trcksmatch; //Key is BT track id, second is TT track id
    std::vector< std::pair<double,double> > trcksmatchVals;

    matchTracks(trcksmatch, trcksmatchVals);

    gAnalyzer->SetBTTTTracksScatterSize(trcksmatch.size());

    for (std::map<int,int>::iterator it=trcksmatch.begin(); it!=trcksmatch.end(); ++it) {
//      std::cout <<"Tracks match found between BT at TT tracks: "<< it->first << " => " << it->second << std::endl;

      rAPPNUWSRecoTracksTT *aTrkTT = gAnalyzer->GetRecoTracksTTAt(it->second);
      CLHEP::Hep3Vector posTT1 ( aTrkTT->Getpos1()->X(), aTrkTT->Getpos1()->Y(), aTrkTT->Getpos1()->Z() );
      TVector3 *posTT0 = aTrkTT->Getpos0();
      Double_t *errPosTT0 = aTrkTT->GeterrPos0();
//      Double_t *errPosTT1 = aTrkTT->GeterrPos1();
      TVector3 tmpdirTT1;
      tmpdirTT1.SetMagThetaPhi( 1.0, aTrkTT->Gettheta1(), aTrkTT->Getphi1() );
      CLHEP::Hep3Vector dirTT1 ( tmpdirTT1.X(), tmpdirTT1.Y(), tmpdirTT1.Z() );
//      dirTT1.setRhoPhiTheta( 1.0, aTrkTT->Getphi1(), aTrkTT->Gettheta1() );

//      std::cout<<"TT dir1 (TVector3) ";tmpdirTT1.Print();
//      std::cout<<"TT dir1 (Hep3Vector) "<<dirTT1<<std::endl;

      rAPPNUWSRecoTracksBT *aTrkBT = gAnalyzer->GetRecoTracksBTAt(it->first);
      CLHEP::Hep3Vector posBT0( aTrkBT->Getpos0()->X(), aTrkBT->Getpos0()->Y(), aTrkBT->Getpos0()->Z() );
      TVector3 *posBT1 = aTrkBT->Getpos1();
//      Double_t *errPosBT0 = aTrkBT->GeterrPos0();
      Double_t *errPosBT1 = aTrkBT->GeterrPos1();
      TVector3 tmpdirBT0;
      tmpdirBT0.SetMagThetaPhi( 1.0, aTrkBT->Gettheta(), aTrkBT->Getphi() );
      CLHEP::Hep3Vector dirBT0 ( tmpdirBT0.X(), tmpdirBT0.Y(), tmpdirBT0.Z() );
//      dirBT0.setRhoPhiTheta( 1.0, aTrkBT->Getphi(), aTrkBT->Gettheta() );


      // Step is not a point. Calculate the distance between two lines.
      TwoLinePCA pca( posTT1, dirTT1, posBT0, dirBT0);
      if ( !pca.closeToParallel() ) {
          CLHEP::Hep3Vector const& p2 = pca.point2();
          //double hit_dca_l = pca.dca();
          CLHEP::Hep3Vector const& p1 = pca.point1();

//          std::cout<<"Intersection point: 1 "<<p1<<" 2 "<<p2<<std::endl;
//          std::cout<<"match id "<<itrckm<<" match dist "<<trcksmatchVals.at(itrckm).first<<" angle "<<trcksmatchVals.at(itrckm).second<<std::endl;

          int itrckm = std::distance(trcksmatch.begin(), it);
          rAPPNUWSBTTTTracksScatter *aBTTTmtch = gAnalyzer->GetBTTTTracksScatterAt(itrckm);
          aBTTTmtch->SetTrk1ID(it->first);
          aBTTTmtch->SetTrk2ID(it->second);
          aBTTTmtch->Setpos( TVector3( (p1.x()+p2.x())*0.5,  (p1.y()+p2.y())*0.5,  (p1.z()+p2.z())*0.5 ) );
          aBTTTmtch->Setdist(trcksmatchVals.at(itrckm).first);
          aBTTTmtch->Setangle(trcksmatchVals.at(itrckm).second);

          bool potOneTrk=false; //compatible with one track fit

          for( int iT=0; iT<gAnalyzer->GetRecoTracksSize(); ++iT ){

      //        trckmatch[iTT]=-1;
              TVector3 *posT[2];
              Double_t *errPosT[2];
              rAPPNUWSRecoTracks *aTrk = gAnalyzer->GetRecoTracksAt(iT);

              if ( aTrk->GetIsFitted() ) {

                  double tchi2n = aTrk->Getchi2()/((double)aTrk->Getdof());
                  if ( (aTrk->GetngoodhitsTT()>2 && aTrk->GetngoodhitsBT()>2) && tchi2n>1e-6&&tchi2n<20) {
                      posT[0] = aTrk->Getpos0();
                      errPosT[0] = aTrk->GeterrPos0();
      //                dirTT[0].SetMagThetaPhi( 1.0, aTrkTT->Gettheta(), aTrkTT->Getphi() );

                      posT[1] = aTrk->Getpos1();
                      errPosT[1] = aTrk->GeterrPos1();
      //                dirTT[1].SetMagThetaPhi( 1.0, aTrkTT->Gettheta1(), aTrkTT->Getphi1() );

                      double errDist0 = sqrt( errPosT[0][0]*errPosT[0][0] + errPosT[0][2]*errPosT[0][2] + errPosTT0[0]*errPosTT0[0] + errPosTT0[2]*errPosTT0[2] );
                      double errDist1 = sqrt( errPosT[1][0]*errPosT[1][0] + errPosT[1][2]*errPosT[1][2] + errPosBT1[0]*errPosBT1[0] + errPosBT1[2]*errPosBT1[2] );
                      if ( (*posT[0] - *posTT0).Mag()<5.0*errDist0 &&
                           (*posT[1] - *posBT1).Mag()<5.0*errDist1  ) {
                          potOneTrk=true;
                          break;
                      }
                  }
              }
          }
          aBTTTmtch->SetOneTrackMatch(potOneTrk);

      }

    }

//    TVector3 *posTT[3], *posBT[3];
//    Double_t *errPosTT[3], *errPosBT[3];
//    TVector3 dirTT[3], dirBT[3];
//
//    std::cout<<"------------------- TT -------------------"<<std::endl;
//    for( int iTT=0; iTT<gAnalyzer->GetRecoTracksTTSize(); ++iTT ){
//
//        rAPPNUWSRecoTracksTT *aTrkTT = gAnalyzer->GetRecoTracksTTAt(iTT);
//
//        if ( aTrkTT->GetIsFitted() ) {
//
//            double ttchi2n = aTrkTT->Getchi2()/((double)aTrkTT->Getdof());
//            if (ttchi2n>1e-6&&ttchi2n<20) {
//                //                    ROOT::Math::XYZPoint ttx0( aTrkTT->Getx0(), aTrkTT->Gety0(), aTrkTT->Getz0() );
//                //                    ROOT::Math::XYZVector ttm0( aTrkTT->Getx0(), aTrkTT->Gety0(), aTrkTT->Getz0() );
//
//                posTT[0] = aTrkTT->Getpos0();
//                errPosTT[0] = aTrkTT->GeterrPos0();
//                dirTT[0].SetMagThetaPhi( 1.0, aTrkTT->Gettheta(), aTrkTT->Getphi() );
//
//                posTT[1] = aTrkTT->Getpos1();
//                errPosTT[1] = aTrkTT->GeterrPos1();
//                dirTT[1].SetMagThetaPhi( 1.0, aTrkTT->Gettheta1(), aTrkTT->Getphi1() );
//
//                posTT[2] = aTrkTT->Getpos2();
//                errPosTT[2] = aTrkTT->GeterrPos2();
//                dirTT[2].SetMagThetaPhi( 1.0, aTrkTT->Gettheta2(), aTrkTT->Getphi2() );
//
//                std::cout<<"Pos0 "; posTT[0]->Print();
//                std::cout<<"Dir0 "; dirTT[0].Print();
//                std::cout<<"Pos1 "; posTT[1]->Print();
//                std::cout<<"Dir1 "; dirTT[1].Print();
//                std::cout<<"Pos2 "; posTT[2]->Print();
//                std::cout<<"Dir2 "; dirTT[2].Print();
//            }
//        }
//    }
//
//std::cout<<"------------------- BT -------------------"<<std::endl;
//    for(int i=0;i<gAnalyzer->GetRecoTracksBTSize();i++){
//        rAPPNUWSRecoTracksBT *aTrkBT = gAnalyzer->GetRecoTracksBTAt(i);
//        if ( aTrkBT->GetIsFitted() ) {
//            double ttchi2n = aTrkBT->Getchi2()/((double)aTrkBT->Getdof());
//            if (ttchi2n>1e-6&&ttchi2n<20) {
//                posBT[0] = aTrkBT->Getpos0();
//                errPosBT[0] = aTrkBT->GeterrPos0();
//                dirBT[0].SetMagThetaPhi( 1.0, aTrkBT->Gettheta(), aTrkBT->Getphi() );
//
//                posBT[1] = aTrkBT->Getpos1();
//                errPosBT[1] = aTrkBT->GeterrPos1();
//                dirBT[1].SetMagThetaPhi( 1.0, aTrkBT->Gettheta1(), aTrkBT->Getphi1() );
//
//                posBT[2] = aTrkBT->Getpos2();
//                errPosBT[2] = aTrkBT->GeterrPos2();
//                dirBT[2].SetMagThetaPhi( 1.0, aTrkBT->Gettheta2(), aTrkBT->Getphi2() );
//
//                std::cout<<"Pos0 "; posBT[0]->Print();
//                std::cout<<"Dir0 "; dirBT[0].Print();
//                std::cout<<"Pos1 "; posBT[1]->Print();
//                std::cout<<"Dir1 "; dirBT[1].Print();
//                std::cout<<"Pos2 "; posBT[2]->Print();
//                std::cout<<"Dir2 "; dirBT[2].Print();
//
//            }
//        }
//    }
//
//    for(int i=0;i<gAnalyzer->GetRecoTracksSize();i++){
//        rAPPNUWSRecoTracks *aTrk = gAnalyzer->GetRecoTracksAt(i);
//    }


}

void rAPPNUWSTTrackFit::matchTracks( std::map<int,int> &trckmatch, std::vector< std::pair<double,double> > &trckmatchVals ) {

    TVector3 *posTT[3], *posBT[3];
    Double_t *errPosTT[3], *errPosBT[3];
    TVector3 dirTT[3], dirBT[3];

    for( int iTT=0; iTT<gAnalyzer->GetRecoTracksTTSize(); ++iTT ){

//        trckmatch[iTT]=-1;

        rAPPNUWSRecoTracksTT *aTrkTT = gAnalyzer->GetRecoTracksTTAt(iTT);

        if ( aTrkTT->GetIsFitted() ) {

            double ttchi2n = aTrkTT->Getchi2()/((double)aTrkTT->Getdof());
            if (ttchi2n>1e-6&&ttchi2n<20) {
                //                    ROOT::Math::XYZPoint ttx0( aTrkTT->Getx0(), aTrkTT->Gety0(), aTrkTT->Getz0() );
                //                    ROOT::Math::XYZVector ttm0( aTrkTT->Getx0(), aTrkTT->Gety0(), aTrkTT->Getz0() );

//                posTT[0] = aTrkTT->Getpos0();
//                errPosTT[0] = aTrkTT->GeterrPos0();
//                dirTT[0].SetMagThetaPhi( 1.0, aTrkTT->Gettheta(), aTrkTT->Getphi() );
//
//                posTT[1] = aTrkTT->Getpos1();
//                errPosTT[1] = aTrkTT->GeterrPos1();
//                dirTT[1].SetMagThetaPhi( 1.0, aTrkTT->Gettheta1(), aTrkTT->Getphi1() );

                posTT[2] = aTrkTT->Getpos2();
                errPosTT[2] = aTrkTT->GeterrPos2();
                dirTT[2].SetMagThetaPhi( 1.0, aTrkTT->Gettheta2(), aTrkTT->Getphi2() );

                double distMatch=1e10, angleMatch=0.0;
                int iBTmatch=-1;
                for(int iBT=0; iBT<gAnalyzer->GetRecoTracksBTSize(); ++iBT){

//                    if (trckmatch[iTT]==iBT) { continue; }
                    if ( trckmatch.find(iBT) != trckmatch.end() ) { continue; }

                    rAPPNUWSRecoTracksBT *aTrkBT = gAnalyzer->GetRecoTracksBTAt(iBT);
                    if ( aTrkBT->GetIsFitted() ) {
                        double ttchi2n = aTrkBT->Getchi2()/((double)aTrkBT->Getdof());
                        if (ttchi2n>1e-6&&ttchi2n<20) {
                            posBT[0] = aTrkBT->Getpos0();
                            errPosBT[0] = aTrkBT->GeterrPos0();
                            dirBT[0].SetMagThetaPhi( 1.0, aTrkBT->Gettheta(), aTrkBT->Getphi() );

//                            posBT[1] = aTrkBT->Getpos1();
//                            errPosBT[1] = aTrkBT->GeterrPos1();
//                            dirBT[1].SetMagThetaPhi( 1.0, aTrkBT->Gettheta1(), aTrkBT->Getphi1() );
//
//                            posBT[2] = aTrkBT->Getpos2();
//                            errPosBT[2] = aTrkBT->GeterrPos2();
//                            dirBT[2].SetMagThetaPhi( 1.0, aTrkBT->Gettheta2(), aTrkBT->Getphi2() );

                            double distTmp=(*posTT[2]-*posBT[0]).Mag();
                            double angleTmp=dirTT[2].Angle(dirBT[0]);

                            if (GetSP()->GetDebugLevel()>1) {
                                std::cout<<"Track segments match checking: dist "<<distTmp<<" angle "<<angleTmp<<std::endl;
                            }

                            if ( angleTmp<angleCut && distTmp<distCut ) {
                                if ( distTmp<distMatch ) {
                                    distMatch=distTmp;
                                    angleMatch=angleTmp;
//                                    trckmatch[iTT]=iBT;
                                    iBTmatch=iBT;
                                }
                            }

                        }
                    }
                }
                if ( iBTmatch>-1 ) {
                    trckmatch[iBTmatch]=iTT;
                    trckmatchVals.push_back( std::pair<double,double>(distMatch,angleMatch) );
                }

            }
        }

//        if (trckmatch[iTT]==-1) { trckmatch.erase(iTT); }
    }

}

double sgmTheta(TVector3 &mom, TMatrixDSym &cov) {
    double sgTh=0.0;
    double sgpx2 = 0.0, sgpy2 = 0.0, sgpz2 = 0.0;
    double sgpxy = 0.0, sgpxz = 0.0, sgpyz = 0.0;
    double px = 0.0, py = 0.0, pz = 0.0;
    double px2 = 0.0, py2 = 0.0, pz2 = 0.0, pt2 = 0.0;
    px = fabs(mom[0]);
//    px = mom[0];
    px2 = px*px;
    py = fabs(mom[1]);
//    py = mom[1];
    py2 = py*py;
    pz = fabs(mom[2]);
//    pz = mom[2];
    pz2 = pz*pz;
    sgpx2 = cov[3][3];
    sgpy2 = cov[4][4];
    sgpz2 = cov[5][5];

    pt2 = px2 + py2;
    sgpxy = cov[3][4];
    sgpxz = cov[3][5];
    sgpyz = cov[4][5];
//    if (mom.Theta()>TMath::PiOver2()) {
//        sgpxy *= -1.0;
//        sgpxz *= -1.0;
//        sgpyz *= -1.0;
//    }

    mom.Print();
    cov.Print();
//    std::cout<<"px "<<px<<" py "<<py<<" pz "<<pz<<" sgpx2 "<<sgpx2<<" sgpz2 "<<sgpz2<<std::endl;

    sgTh = fabs(pz)/pt2 * sqrt ( px2/pt2*sgpx2 + py2/pt2*sgpy2 + pt2/pz2*sgpz2 + 2*px*py/pt2*sgpxy + 2*px/pz*sgpxz + 2*py/pz*sgpyz );
//    sgTh = fmod(sgTh,TMath::Pi());

    std::cout<<"sgTh "<<sgTh<<std::endl;
    std::cout<<"sgTh1 "<<fabs(pz)/pt2 * sqrt ( px2/pt2*sgpx2 )<<std::endl;
    std::cout<<"sgTh2 "<<fabs(pz)/pt2 * sqrt ( px2/pt2*sgpx2 + py2/pt2*sgpy2 )<<std::endl;
    std::cout<<"sgTh3 "<<fabs(pz)/pt2 * sqrt ( px2/pt2*sgpx2 + py2/pt2*sgpy2 + pt2/pz2*sgpz2 )<<std::endl;
    std::cout<<"sgTh4 "<<fabs(pz)/pt2 * sqrt ( px2/pt2*sgpx2 + py2/pt2*sgpy2 + pt2/pz2*sgpz2 + 2*px*py/pt2*sgpxy )<<std::endl;
    std::cout<<"sgTh5 "<<fabs(pz)/pt2 * sqrt ( px2/pt2*sgpx2 + py2/pt2*sgpy2 + pt2/pz2*sgpz2 + 2*px*py/pt2*sgpxy + 2*px/pz*sgpxz )<<std::endl;

    return sgTh;
}

double sgmPhi(TVector3 &mom, TMatrixDSym &cov) {
    double sgPh=0.0;
    double sgpx2 = 0.0, sgpy2 = 0.0;
    double sgpxy = 0.0;
    double px = 0.0, py = 0.0;
    double px2 = 0.0, py2 = 0.0;
    px = fabs(mom[0]);
    px2 = px*px;
    py = fabs(mom[1]);
    py2 = py*py;
    sgpx2 = cov[3][3];
    sgpy2 = cov[4][4];

    sgpxy = cov[3][4];

    mom.Print();
    cov.Print();
//    std::cout<<"id "<<id<<" px "<<px<<" pz "<<pz<<" sgpx2 "<<sgpx2<<" sgpz2 "<<sgpz2<<std::endl;

    sgPh = fabs(px)/(px2+py2) * sqrt ( py2/px2*sgpx2 + sgpy2 + 2*py/px*sgpxy );
    sgPh = fmod(sgPh,TMath::Pi());

    std::cout<<"sgPh "<<sgPh<<std::endl;
    std::cout<<"sgPh1 "<<fabs(px)/(px2+py2) * sqrt ( py2/px2*sgpx2 )<<std::endl;
    std::cout<<"sgPh2 "<<fabs(px)/(px2+py2) * sqrt ( py2/px2*sgpx2 + sgpy2 )<<std::endl;

    return sgPh;
}

//double sgmAngle(TVector3 &mom, TMatrixDSym &cov, int id) {
//    double sgAng=0.0;
//    double sgpc1_2 = 0.0, sgpc2_2 = 0.0;
//    double pc1 = 0.0, pc2 = 0.0;
//    double pc1_2 = 0.0, pc2_2 = 0.0;
//    if (id==0) {
//        pc1_2 = mom[0]*mom[0] + mom[1]*mom[1];
//        pc1 = sqrt(pc1_2);
//        pc2 = fabs(mom[2]);
//        pc2_2 = pc2*pc2;
//        sgpc1_2 = cov[3][3] + cov[4][4];
//        sgpc2_2 = cov[5][5];
//    } else {
//        pc1_2 = mom[1]*mom[1];
//        pc1 = fabs(mom[1]);
//        pc2 = fabs(mom[0]);
//        pc2_2 = pc2*pc2;
//        sgpc1_2 = cov[4][4];
//        sgpc2_2 = cov[3][3];
//    }
//
//    mom.Print();
//    cov.Print();
//    std::cout<<"id "<<id<<" pc1 "<<pc1<<" pc2 "<<pc2<<" sgpc1_2 "<<sgpc1_2<<" sgpc2_2 "<<sgpc2_2<<std::endl;
//
//    sgAng = pc2 / (pc1_2 + pc2_2) * sqrt ( sgpc1_2 + pc1_2/pc2_2 * sgpc2_2 );
//
//    std::cout<<"sgAng "<<sgAng<<std::endl;
//    std::cout<<"sgAng1 "<<pc2 / (pc1_2 + pc2_2) * sqrt ( sgpc1_2 )<<std::endl;
//    std::cout<<"sgAng2 "<<pc2 / (pc1_2 + pc2_2) * sqrt ( pc1_2/pc2_2 * sgpc2_2 )<<std::endl;
//
//    return sgAng;
//}

double sgmTheta1(TVector3 &mom, TMatrixDSym &cov) {
    double sgTh=0.0;
    double sgpx2 = 0.0, sgpy2 = 0.0, sgpz2 = 0.0;
    double sgpxy = 0.0, sgpxz = 0.0, sgpyz = 0.0;
    double px = 0.0, py = 0.0, pz = 0.0;
    double px2 = 0.0, py2 = 0.0, pz2 = 0.0, pt2 = 0.0, p2 = 0.0;
//    px = fabs(mom[0]);
    px = mom[0];
    px2 = px*px;
//    py = fabs(mom[1]);
    py = mom[1];
    py2 = py*py;
//    pz = fabs(mom[2]);
    pz = mom[2];
    pz2 = pz*pz;
    sgpx2 = cov[3][3];
    sgpy2 = cov[4][4];
    sgpz2 = cov[5][5];

    pt2 = px2 + py2;
    p2 = pt2 + pz2;
    sgpxy = cov[3][4];
    sgpxz = cov[3][5];
    sgpyz = cov[4][5];
//    if (mom.Theta()>TMath::PiOver2()) {
//        sgpxy *= -1.0;
//        sgpxz *= -1.0;
//        sgpyz *= -1.0;
//    }

    mom.Print();
    cov.Print();
//    std::cout<<"px "<<px<<" py "<<py<<" pz "<<pz<<" sgpx2 "<<sgpx2<<" sgpz2 "<<sgpz2<<std::endl;

    double sgp2 = (px2*sgpx2 + py2*sgpy2 + pz2*sgpz2 +
                           2.0*px*py*sgpxy + 2.0*px*pz*sgpxz + 2.0*py*pz*sgpyz ) / p2;

    sgTh = sqrt ( (sgpz2 + px2/p2 * sgp2) / pt2 );
//    sgTh = fmod(sgTh,TMath::Pi());

    std::cout<<"sgTh "<<sgTh<<std::endl;
    std::cout<<"sgTh1 "<<sqrt ( (sgpz2 ) / pt2 )<<std::endl;

    return sgTh;
}
